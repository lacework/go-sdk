package main

import (
	"fmt"
	"log"
	"os"
	"time"

	"github.com/lacework/go-sdk/api"
)

func main() {
	lacework, err := api.NewClient(os.Getenv("LW_ACCOUNT"),
		api.WithSubaccount(os.Getenv("LW_SUBACCOUNT")),
		api.WithApiKeys(os.Getenv("LW_API_KEY"), os.Getenv("LW_API_SECRET")),
	)
	if err != nil {
		log.Fatal(err)
	}

	res, err := lacework.V2.VulnerabilityExceptions.List()
	if err != nil {
		log.Fatal(err)
	}

	for _, exception := range res.Data {
		support := "Unsupported"
		switch exception.ExceptionType {
		case api.VulnerabilityExceptionTypeHost.String():
			support = "Supported"
		case api.VulnerabilityExceptionTypeContainer.String():
			support = "Supported"
		}

		// Output: GUID:VULN_EXCEPTION_TYPE:[Supported|Unsupported]
		fmt.Printf("%s:%s:%s\n", exception.Guid, exception.ExceptionType, support)
	}

	exception := api.VulnerabilityExceptionConfig{
		Type:            api.VulnerabilityExceptionTypeContainer,
		Description:     "This is a vuln exception",
		ExceptionReason: api.VulnerabilityExceptionReasonCompensatingControls,
		Severities:      api.VulnerabilityExceptionSeverities{api.VulnerabilityExceptionSeverityCritical},
		Package:         []api.VulnerabilityExceptionPackage{{Name: "PackageOne", Version: "1.0.0"}},
		ResourceScope: api.VulnerabilityExceptionContainerResourceScope{
			ImageTag: []string{"MyImage"},
		},
		ExpiryTime: time.Now().AddDate(0, 1, 0),
	}

	myVulnException := api.NewVulnerabilityException("MyVulnException",
		exception,
	)

	response, err := lacework.V2.VulnerabilityExceptions.Create(myVulnException)
	if err != nil {
		log.Fatal(err)
	}

	// Output: Vulnerability Exception created: GUID
	fmt.Printf("Vulnerability Exception created: %s", response.Data.Guid)

	err = lacework.V2.VulnerabilityExceptions.Delete(response.Data.Guid)
	if err != nil {
		log.Fatal(err)
	}

	// Output: Vulnerability Exception deleted: GUID
	fmt.Printf("Vulnerability Exception deleted: %s", response.Data.Guid)
}
