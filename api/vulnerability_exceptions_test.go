//
// Author:: Darren Murray (<darren.murray@lacework.net>)
// Copyright:: Copyright 2021, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package api_test

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/aws/smithy-go/ptr"
	"github.com/stretchr/testify/assert"

	"github.com/lacework/go-sdk/api"
	"github.com/lacework/go-sdk/internal/intgguid"
	"github.com/lacework/go-sdk/internal/lacework"
)

func TestNewVulnerabilityException(t *testing.T) {
	mypackages := []api.VulnerabilityExceptionPackage{
		{
			Name:    "PackageOne",
			Version: "1.2.3",
		},
		{
			Name:    "PackageOne",
			Version: "1.2.4",
		}, {
			Name:    "PackageTwo",
			Version: "1.2.3",
		},
	}
	expiry, _ := time.Parse(time.RFC3339, "2021-12-31T18:47:07Z")

	fixable := true
	vulnerabilityException := api.NewVulnerabilityException("MyVulnException",
		api.VulnerabilityExceptionConfig{
			Type:            api.VulnerabilityExceptionTypeHost,
			Description:     "This is a vuln exception",
			ExceptionReason: api.VulnerabilityExceptionReasonCompensatingControls,
			Severities:      api.VulnerabilityExceptionSeverities{api.VulnerabilityExceptionSeverityCritical},
			Fixable:         &fixable,
			Package:         mypackages,
			ResourceScope: api.VulnerabilityExceptionHostResourceScope{
				Hostname: []string{"exampleHost1"},
			},
			ExpiryTime: expiry,
		})

	vulnJson, err := json.Marshal(vulnerabilityException)

	assert.NoError(t, err)
	assert.Equal(t, mockVulnHostRequest, string(vulnJson))
	assert.Equal(t, []string{"1.2.3", "1.2.4"}, vulnerabilityException.VulnerabilityCriteria.Package[0]["PackageOne"])
	assert.Equal(t, []string{"Critical"}, vulnerabilityException.VulnerabilityCriteria.Severity)
}

func TestNewVulnerabilityExceptionNoResourceScope(t *testing.T) {
	mypackages := []api.VulnerabilityExceptionPackage{
		{Name: "PackageOne", Version: "1.2.3"},
		{Name: "PackageOne", Version: "1.2.4"},
		{Name: "PackageTwo", Version: "1.2.3"},
	}
	expiry, _ := time.Parse(time.RFC3339, "2021-12-31T18:47:07Z")

	fixable := true
	vulnerabilityException := api.NewVulnerabilityException("MyVulnException",
		api.VulnerabilityExceptionConfig{
			Type:            api.VulnerabilityExceptionTypeHost,
			Description:     "This is a vuln exception",
			ExceptionReason: api.VulnerabilityExceptionReasonCompensatingControls,
			Severities:      api.VulnerabilityExceptionSeverities{api.VulnerabilityExceptionSeverityCritical},
			Fixable:         &fixable,
			Package:         mypackages,
			ExpiryTime:      expiry,
		})

	vulnJson, err := json.Marshal(vulnerabilityException)
	assert.NoError(t, err)
	assert.Equal(t, mockVulnHostWithoutResourceScopeRequest, string(vulnJson))
	assert.Equal(t, []string{"1.2.3", "1.2.4"}, vulnerabilityException.VulnerabilityCriteria.Package[0]["PackageOne"])
	assert.Equal(t, []string{"Critical"}, vulnerabilityException.VulnerabilityCriteria.Severity)
}

func TestHostVulnerabilityExceptionGet(t *testing.T) {
	var (
		intgGUID      = intgguid.New()
		apiPath       = fmt.Sprintf("VulnerabilityExceptions/%s", intgGUID)
		vulnException = singleMockHostVulnerabilityException(intgGUID)
		fakeServer    = lacework.MockServer()
	)
	fakeServer.MockToken("TOKEN")
	defer fakeServer.Close()

	fakeServer.MockAPI(apiPath,
		func(w http.ResponseWriter, r *http.Request) {
			if assert.Equal(t, "GET", r.Method, "Get() should be a GET method") {
				fmt.Fprintf(w, generateVulnerabilityExceptionResponse(vulnException))
			}
		},
	)

	fakeServer.MockAPI("VulnerabilityExceptions/UNKNOWN_INTG_GUID",
		func(w http.ResponseWriter, r *http.Request) {
			if assert.Equal(t, "GET", r.Method, "Get() should be a GET method") {
				http.Error(w, "{ \"message\": \"Not Found\"}", 404)
			}
		},
	)

	c, err := api.NewClient("test",
		api.WithToken("TOKEN"),
		api.WithURL(fakeServer.URL()),
	)
	assert.Nil(t, err)

	t.Run("when vulnerability exception exists", func(t *testing.T) {
		var response api.VulnerabilityExceptionResponse
		err := c.V2.VulnerabilityExceptions.Get(intgGUID, &response)
		assert.Nil(t, err)
		if assert.NotNil(t, response) {
			assert.Equal(t, intgGUID, response.Data.Guid)
			assert.Equal(t, "Example Vuln Exception", response.Data.ExceptionName)
			assert.Equal(t, "Host", response.Data.ExceptionType)
		}
	})

	t.Run("when vulnerability exception does NOT exist", func(t *testing.T) {
		var response api.VulnerabilityExceptionResponse
		err := c.V2.VulnerabilityExceptions.Get("UNKNOWN_INTG_GUID", response)
		assert.Empty(t, response)
		if assert.NotNil(t, err) {
			assert.Contains(t, err.Error(), "api/v2/VulnerabilityExceptions/UNKNOWN_INTG_GUID")
			assert.Contains(t, err.Error(), "[404] Not Found")
		}
	})
}

func TestCtrVulnerabilityExceptionGet(t *testing.T) {
	var (
		intgGUID      = intgguid.New()
		apiPath       = fmt.Sprintf("VulnerabilityExceptions/%s", intgGUID)
		vulnException = singleMockCtrVulnerabilityException(intgGUID)
		fakeServer    = lacework.MockServer()
	)
	fakeServer.MockToken("TOKEN")
	defer fakeServer.Close()

	fakeServer.MockAPI(apiPath,
		func(w http.ResponseWriter, r *http.Request) {
			if assert.Equal(t, "GET", r.Method, "Get() should be a GET method") {
				fmt.Fprintf(w, generateVulnerabilityExceptionResponse(vulnException))
			}
		},
	)

	fakeServer.MockAPI("VulnerabilityExceptions/UNKNOWN_INTG_GUID",
		func(w http.ResponseWriter, r *http.Request) {
			if assert.Equal(t, "GET", r.Method, "Get() should be a GET method") {
				http.Error(w, "{ \"message\": \"Not Found\"}", 404)
			}
		},
	)

	c, err := api.NewClient("test",
		api.WithToken("TOKEN"),
		api.WithURL(fakeServer.URL()),
	)
	assert.Nil(t, err)

	t.Run("when vulnerability exception exists", func(t *testing.T) {
		var response api.VulnerabilityExceptionResponse
		err := c.V2.VulnerabilityExceptions.Get(intgGUID, &response)
		assert.Nil(t, err)
		if assert.NotNil(t, response) {
			assert.Equal(t, intgGUID, response.Data.Guid)
			assert.Equal(t, "Example Vuln Exception", response.Data.ExceptionName)
			assert.Equal(t, "Container", response.Data.ExceptionType)
			assert.Equal(t, []string{"test1", "test2"}, response.Data.ResourceScope.Repository)
			assert.Equal(t, []string{"test1", "test2"}, response.Data.ResourceScope.Registry)
			assert.Equal(t, []string{"test1", "test2"}, response.Data.ResourceScope.ImageID)
			assert.Equal(t, []string{"test1", "test2"}, response.Data.ResourceScope.Namespace)
		}
	})

	t.Run("when vulnerability exception does NOT exist", func(t *testing.T) {
		var response api.VulnerabilityExceptionResponse
		err := c.V2.VulnerabilityExceptions.Get("UNKNOWN_INTG_GUID", response)
		assert.Empty(t, response)
		if assert.NotNil(t, err) {
			assert.Contains(t, err.Error(), "api/v2/VulnerabilityExceptions/UNKNOWN_INTG_GUID")
			assert.Contains(t, err.Error(), "[404] Not Found")
		}
	})
}

func TestVulnerabilityExceptionsList(t *testing.T) {
	var (
		allGUIDs                []string
		vulnerabilityExceptions = generateGuids(&allGUIDs, 3)
		expectedLen             = len(allGUIDs)
		fakeServer              = lacework.MockServer()
	)

	fakeServer.MockToken("TOKEN")
	fakeServer.MockAPI("VulnerabilityExceptions",
		func(w http.ResponseWriter, r *http.Request) {
			assert.Equal(t, "GET", r.Method, "List() should be a GET method")
			vulnerabilityExceptions := []string{
				generateVulnerabilityExceptions(vulnerabilityExceptions),
			}
			fmt.Fprintf(w,
				generateVulnerabilityExceptionsResponse(
					strings.Join(vulnerabilityExceptions, ", "),
				),
			)
		},
	)
	defer fakeServer.Close()

	c, err := api.NewClient("test",
		api.WithToken("TOKEN"),
		api.WithURL(fakeServer.URL()),
	)
	assert.Nil(t, err)

	response, err := c.V2.VulnerabilityExceptions.List()
	assert.Nil(t, err)
	assert.NotNil(t, response)
	assert.Equal(t, expectedLen, len(response.Data))
	for _, d := range response.Data {
		assert.Contains(t, allGUIDs, d.Guid)
	}
}

func TestVulnerabilityExceptionUpdate(t *testing.T) {
	var (
		intgGUID   = intgguid.New()
		apiPath    = fmt.Sprintf("VulnerabilityExceptions/%s", intgGUID)
		fakeServer = lacework.MockServer()
	)
	expiry, _ := time.Parse(time.RFC3339, "2021-12-31T18:47:07Z")
	fakeServer.MockToken("TOKEN")
	defer fakeServer.Close()

	fakeServer.MockAPI(apiPath, func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "PATCH", r.Method, "Update() should be a PATCH method")

		if assert.NotNil(t, r.Body) {
			body := httpBodySniffer(r)
			assert.Contains(t, body, "MyVulnException", "vulnerability exception name is missing")
			assert.Contains(t, body, "Host", "wrong vulnerability exception type")
		}

		fmt.Fprintf(w, generateVulnerabilityExceptionResponse(singleMockHostVulnerabilityException(intgGUID)))
	})

	c, err := api.NewClient("test",
		api.WithToken("TOKEN"),
		api.WithURL(fakeServer.URL()),
	)
	assert.Nil(t, err)

	fixable := true
	vulnerabilityException := api.NewVulnerabilityException("MyVulnException",
		api.VulnerabilityExceptionConfig{
			Type:            api.VulnerabilityExceptionTypeHost,
			Description:     "This is a vuln exception",
			ExceptionReason: api.VulnerabilityExceptionReasonCompensatingControls,
			Severities:      api.VulnerabilityExceptionSeverities{api.VulnerabilityExceptionSeverityCritical},
			Fixable:         &fixable,
			Package:         []api.VulnerabilityExceptionPackage{{"pck", "1.0.0"}},
			ResourceScope: api.VulnerabilityExceptionHostResourceScope{
				Hostname: []string{"exampleHost1"},
			},
			ExpiryTime: expiry,
		})

	assert.Equal(t, "MyVulnException", vulnerabilityException.ExceptionName, "vulnerability exception name mismatch")
	assert.Equal(t, "Host", vulnerabilityException.ExceptionType, "a new vulnerability exception should match its type")
	assert.Equal(t, 1, vulnerabilityException.Enabled, "a new vulnerability exception should be enabled")

	vulnerabilityException.Guid = intgGUID
	response, err := c.V2.VulnerabilityExceptions.Update(vulnerabilityException)
	if assert.NoError(t, err) {
		assert.NotNil(t, response)
		assert.Equal(t, intgGUID, response.Data.Guid)
		assert.Equal(t, response.Data.VulnerabilityCriteria.Fixable[0], 1)
		assert.Equal(t, response.Data.ResourceScope.Hostname[0], "exampleHost1")
		assert.Equal(t, response.Data.VulnerabilityCriteria.Package[0]["pck"][0], "1.0.0")
	}
}

func TestFixableEnabled(t *testing.T) {
	tests := []struct {
		name     string
		value    []int
		expected *bool
	}{
		{"fixable is false", []int{0}, ptr.Bool(false)},
		{"fixable is true", []int{1}, ptr.Bool(true)},
		{"fixable is empty", []int{}, nil},
		{"fixable is nil", nil, nil},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			criteria := api.VulnerabilityExceptionCriteria{Fixable: test.value}
			assert.Equal(t, criteria.FixableEnabled(), test.expected)
		})
	}
}

func generateVulnerabilityExceptions(guids []string) string {
	vulnerabilityExceptions := make([]string, len(guids))
	for i, guid := range guids {
		vulnerabilityExceptions[i] = singleMockHostVulnerabilityException(guid)
	}
	return strings.Join(vulnerabilityExceptions, ", ")
}

func generateVulnerabilityExceptionsResponse(data string) string {
	return `
		{
			"data": [` + data + `]
		}
	`
}

func generateVulnerabilityExceptionResponse(data string) string {
	return `
		{
			"data": ` + data + `
		}
	`
}

func singleMockHostVulnerabilityException(id string) string {
	return fmt.Sprintf(`
{
        "createdTime": "2021-12-02T18:47:24.897Z",
        "envGuid": "TECHALLY_3F75784E9C7660B1F8B4A72E80B2EECCE8EDA92DBE37E5D",
        "exceptionGuid": %q,
        "exceptionName": "Example Vuln Exception",
        "exceptionReason": "Accepted Risk",
        "exceptionType": "Host",
        "expiryTime": "2021-12-31T18:47:07Z",
        "props": {
            "description": "This is a comment",
            "createdBy": "darren.murray@lacework.net",
            "updatedBy": "darren.murray@lacework.net"
        },
        "resourceScope": {
            "hostname": [
                "exampleHost1",
                "exampleHost2"
            ],
            "externalIp": [
                "test1",
                "test2"
            ],
            "clusterName": [
                "test1",
                "test2"
            ],
            "namespace": [
                "test1",
                "test2"
            ]
        },
        "state": 1,
        "updatedTime": "2021-12-03T13:27:33.169Z",
        "vulnerabilityCriteria": {
            "cve": [
                "cve1",
                "cve2"
            ],
            "fixable": [
                1
            ],
            "package": [
                {
                    "pck": [
                        "1.0.0",
                        "2.0.0",
                        "3.0.0"
                    ]
                }
            ],
            "severity": [
                "High",
                "Medium",
                "Low",
                "Critical"
            ]
        }
}
	`, id)
}

func singleMockCtrVulnerabilityException(id string) string {
	return fmt.Sprintf(`
{
        "createdTime": "2021-12-02T18:47:24.897Z",
        "envGuid": "TECHALLY_3F75784E9C7660B1F8B4A72E80B2EECCE8EDA92DBE37E5D",
        "exceptionGuid": %q,
        "exceptionName": "Example Vuln Exception",
        "exceptionReason": "Accepted Risk",
        "exceptionType": "Container",
        "expiryTime": "2021-12-31T18:47:07Z",
        "props": {
            "description": "This is a comment",
            "createdBy": "darren.murray@lacework.net",
            "updatedBy": "darren.murray@lacework.net"
        },
        "resourceScope": {
            "imageId": [
                "exampleId",
                "exampleId2"
            ],
            "imageId": [
                "test1",
                "test2"
            ],
            "imageTag": [
                "test1",
                "test2"
            ],
			"registry": [
                "test1",
                "test2"
            ],			
			"repository": [
                "test1",
                "test2"
            ],
            "namespace": [
                "test1",
                "test2"
            ]
        },
        "state": 1,
        "updatedTime": "2021-12-03T13:27:33.169Z",
        "vulnerabilityCriteria": {
            "cve": [
                "cve1",
                "cve2"
            ],
            "fixable": [
                1
            ],
            "package": [
                {
                    "pck": [
                        "1.0.0",
                        "2.0.0",
                        "3.0.0"
                    ]
                }
            ],
            "severity": [
                "High",
                "Medium",
                "Low",
                "Critical"
            ]
        }
}
	`, id)
}

var mockVulnHostRequest = `{"state":1,"exceptionName":"MyVulnException","exceptionType":"Host","exceptionReason":"Compensating Controls","props":{"description":"This is a vuln exception"},"vulnerabilityCriteria":{"package":[{"PackageOne":["1.2.3","1.2.4"]},{"PackageTwo":["1.2.3"]}],"severity":["Critical"],"fixable":[1]},"resourceScope":{"hostname":["exampleHost1"]},"expiryTime":"2021-12-31T18:47:07Z"}`
var mockVulnHostWithoutResourceScopeRequest = `{"state":1,"exceptionName":"MyVulnException","exceptionType":"Host","exceptionReason":"Compensating Controls","props":{"description":"This is a vuln exception"},"vulnerabilityCriteria":{"package":[{"PackageOne":["1.2.3","1.2.4"]},{"PackageTwo":["1.2.3"]}],"severity":["Critical"],"fixable":[1]},"expiryTime":"2021-12-31T18:47:07Z"}`
