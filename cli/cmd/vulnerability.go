//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package cmd

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"

	"github.com/lacework/go-sdk/api"
	"github.com/lacework/go-sdk/lwseverity"
)

var (
	vulCmdState = struct {
		// enable poll mechanism for scans status
		Poll bool

		// store the vulnerability assessment in HTML format on disk
		Html bool

		// output vulnerability assessment in CSV format
		Csv bool

		// when enabled we tread the provided sha256 hash as image id
		ImageID bool

		// display extended details about a vulnerability assessment
		Details bool

		// Filter the vulnerability assessment table by severity
		Severity string

		// Exit the CLI application with an error given a specified severity is met
		FailOnSeverity string

		// Exit the CLI application with an error given fixable vulnerabilities
		FailOnFixable bool

		// display only fixable vulnerabilities
		Fixable bool

		// show a list of packages by number of CVEs
		Packages bool

		// start time for listing assessments
		Start string

		// end time for listing assessments
		End string

		// active flag to filter container vulnerability assessments and
		// show only assessments of containers actively running
		Active bool

		// show only hosts that are online
		Online bool

		// show only hosts that are offline
		Offline bool

		// filter assessments for specific repositories
		Repositories []string

		// filter assessments for specific registries
		Registries []string
	}{}

	// vulnerability represents the vulnerability command that holds both, the host
	// and container sub-commands
	vulnerabilityCmd = &cobra.Command{
		Use:     "vulnerability",
		Aliases: []string{"vuln", "vul"},
		Short:   "Container and host vulnerability assessments",
		Long:    "Container and host vulnerability assessments.",
	}

	// vulContainerCmd represents the vulnerability container command
	vulContainerCmd = &cobra.Command{
		Use:     "container",
		Aliases: []string{"ctr"},
		Short:   "Vulnerability assessment for containers",
		Long: `Request on-demand container vulnerability scans and show previous assessments
from published images.

**PREREQUISITE:** Your Lacework account should already be configured
with a Container Registry Integration of the container images you are
trying to scan or show.

To create a new integration use the following command:

    lacework integration create

If you prefer to configure the integration via the WebUI, log in to your account at:

    https://<ACCOUNT>.lacework.net

Then navigate to Settings > Integrations > Container Registry.`,
	}

	// vulHostCmd represents the vulnerability host command
	vulHostCmd = &cobra.Command{
		Use:   "host",
		Short: "Vulnerability assessment for hosts",
		Long: `Request on-demand host vulnerability scans and show previous assessments
from hosts with the Lacework datacollector agent installed.
`,
	}
)

func init() {
	// add the vulnerability command
	rootCmd.AddCommand(vulnerabilityCmd)

	// add sub-commands to the vulnerability command
	vulnerabilityCmd.AddCommand(vulContainerCmd)
	vulnerabilityCmd.AddCommand(vulHostCmd)
}

func setPollFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Poll, "poll", false, "poll until the vulnerability scan completes")
		}
	}
}

func setPackagesFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Packages, "packages", false,
				"show a list of packages with CVE count",
			)
		}
	}
}

func setFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Fixable, "fixable", false,
				"only show fixable vulnerabilities",
			)
		}
	}
}

func setHtmlFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Html, "html", false,
				"generate a vulnerability assessment in HTML format",
			)
		}
	}
}

func setCsvFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Csv, "csv", false,
				"output vulnerability assessment in CSV format",
			)
		}
	}
}

func setDetailsFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Details, "details", false,
				"increase details of a vulnerability assessment",
			)
		}
	}
}

func setFailOnSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.FailOnSeverity, "fail_on_severity", "",
				fmt.Sprintf("specify a severity threshold to fail if vulnerabilities are found (%s)",
					lwseverity.ValidSeverities.String()),
			)
		}
	}
}

func setFailOnFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.FailOnFixable, "fail_on_fixable", false,
				"fail if the assessed container has fixable vulnerabilities",
			)
		}
	}
}

func setSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.Severity, "severity", "",
				fmt.Sprintf("filter vulnerability assessment by severity threshold (%s)",
					lwseverity.ValidSeverities.String()),
			)
		}
	}
}

func setActiveFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Active, "active", false,
				"only show vulnerabilities of packages actively running in your environment",
			)
		}
	}
}

func pollScanStatus(requestID string) error {
	cli.StartProgress(" Scan running...")

	time.Sleep(time.Second * 64)

	var (
		retries      = 0
		start        = time.Now()
		durationTime = start
		expPollTime  = time.Second
		params       = map[string]interface{}{"request_id": requestID}
	)

	// @afiune bug: there are sometimes that the API returns the scan status as
	// successful without any vulnerabilities, as if the assessment had none, but
	// if you query it again, the assessment does have vulnerabilities.
	//
	// JIRA: RAIN-12964
	// Workaround: Retry the polling mechanism twice on success :(
	bugRetry := true
	for {
		retries++
		params["retries"] = retries

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		durationTime = time.Now()

		cli.Event.Feature = featPollCtrScan
		cli.Event.FeatureData = params

		assessment, err, retry := checkScanStatus(requestID)
		if err != nil {
			cli.Event.Error = err.Error()
			cli.SendHoneyvent()
			return err
		}

		if retry {
			cli.Log.Debugw("waiting for a retry", "request_id", requestID, "sleep", expPollTime)
			cli.SendHoneyvent()
			time.Sleep(expPollTime)
			expPollTime = time.Duration(retries*retries) * time.Second
			continue
		}

		// @afiune bug: there are sometimes that the API returns the scan status as
		// successful without any vulnerabilities, as if the assessment had none, but
		// if you query it again, the assessment does have vulnerabilities.
		//
		// JIRA: RAIN-12964
		// Workaround: Retry the polling mechanism twice on success :(
		if bugRetry {
			bugRetry = false
			cli.SendHoneyvent()
			// we do NOT use the exponential polling time here since this is just a
			// workaround and therefore waiting for 5s or so is enough time
			time.Sleep(time.Second * 5)
			continue
		}

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		params["total_duration_ms"] = time.Since(start).Milliseconds()
		cli.Event.FeatureData = params
		cli.SendHoneyvent()

		// reset event fields
		cli.Event.DurationMs = 0
		cli.Event.FeatureData = nil

		cli.StopProgress()

		if err := buildVulnContainerAssessmentReports(assessment); err != nil {
			return err
		}

		if vulFailureFlagsEnabled() {
			cli.Log.Infow("failure flags enabled",
				"fail_on_severity", vulCmdState.FailOnSeverity,
				"fail_on_fixable", vulCmdState.FailOnFixable,
			)
			vulnPolicy := NewVulnerabilityPolicyError(
				assessment,
				vulCmdState.FailOnSeverity,
				vulCmdState.FailOnFixable,
			)
			if vulnPolicy.NonCompliant() {
				return vulnPolicy
			}
		}

		return nil
	}
}

// Build the cli output for vuln ctr 'scan-status', 'scan' and 'show-assessment' commands
func buildVulnContainerAssessmentReports(assessment *api.VulnContainerAssessment) error {
	if assessment.TotalVulnerabilities == 0 {
		if cli.JSONOutput() {
			return cli.OutputJSON(assessment)
		}
		cli.OutputHuman("Great news! This container image has no vulnerabilities... (time for %s)\n", randomEmoji())
		return nil
	}

	// check if the image pointer is nil, if so, we can't render a report
	if assessment.Image == nil {
		cli.Log.Debugw("image details not found", "assessment", assessment)
		return errors.Errorf("unable to build container vulnerability report. (image information not found)")
	}

	details := vulnerabilityDetailsReport{
		VulnerabilityDetails: filterVulContainerImageLayers(assessment.Image),
		Packages:             filterVulnContainerImagePackages(assessment.Image),
	}

	switch {
	case cli.JSONOutput():
		filteredAssessment := assessment
		filteredAssessment.Image.ImageLayers = details.VulnerabilityDetails.ImageLayers
		if err := cli.OutputJSON(filteredAssessment); err != nil {
			return err
		}
	case cli.CSVOutput():
		if err := cli.OutputCSV(buildVulnerabilityDetailsReportCSV(details)); err != nil {
			return err
		}
	default:
		summaryReport := buildVulnerabilitySummaryReportTable(assessment)
		detailsReport := buildVulnerabilityDetailsReportTable(details)
		cli.OutputHuman(buildVulnContainerAssessmentReportTable(summaryReport, detailsReport))
		if vulCmdState.Html {
			if err := generateVulnAssessmentHTML(assessment); err != nil {
				return err
			}
		}
	}

	return nil
}

type vulnerabilityDetailsReport struct {
	VulnerabilityDetails filteredImageTable
	Packages             filteredPackageTable
}

func buildVulnContainerAssessmentReportTable(summary string, details string) string {
	report := &strings.Builder{}

	report.WriteString(summary)
	if vulCmdState.Details || vulCmdState.Packages || vulFiltersEnabled() {
		report.WriteString(details)
	} else {
		if !vulCmdState.Html {
			report.WriteString(
				"Try adding '--details' to increase details shown about the vulnerability assessment.\n",
			)
		}
	}

	return report.String()
}

func checkScanStatus(requestID string) (*api.VulnContainerAssessment, error, bool) {
	cli.Log.Infow("verifying status of vulnerability scan", "request_id", requestID)
	scan, err := cli.LwApi.Vulnerabilities.Container.ScanStatus(requestID)
	if err != nil {
		return nil, errors.Wrap(err, "unable to verify status of the vulnerability scan"), false
	}

	cli.Log.Debugw("vulnerability scan", "details", scan)
	status := scan.CheckStatus()
	switch status {
	case "Success", "Partial":
		return &scan.Data, nil, false
	case "Scanning":
		return &scan.Data, nil, true
	case "Unsupported":
		return nil, errors.Errorf(
			`unable to run assessment for the provided container image. (unsupported distribution)

For more information about supported distributions, visit:
  https://docs.lacework.com/container-vulnerability-assessment-overview
`,
		), false
	case "NotFound":
		return nil, errors.Errorf(
			"unable to find any vulnerability scan with request id '%s'",
			requestID,
		), false
	case "Failed":
		return nil, errors.New(
			"the vulnerability scan failed to execute. Use '--debug' to troubleshoot.",
		), false
	default:
		return nil, errors.Errorf(
			"unable to get status: '%s' from vulnerability scan. Use '--debug' to troubleshoot.", status), false
	}
}

func severityOrder(severity string) int {
	switch strings.ToLower(severity) {
	case "critical":
		return 1
	case "high":
		return 2
	case "medium":
		return 3
	case "low":
		return 4
	case "info":
		return 5
	default:
		return 6
	}
}

func byteCountBinary(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

func stringToInt(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		cli.Log.Debugw("unable to convert string to int",
			"string", s, "error", err.Error(), "func", "stringToInt",
		)
		return 0
	}
	return i
}

func validateSeverityFlags() error {
	if vulCmdState.Severity != "" {
		if !lwseverity.IsValid(vulCmdState.Severity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.Severity, lwseverity.ValidSeverities.String(),
			)
		}
	}

	if vulCmdState.FailOnSeverity != "" {
		if !lwseverity.IsValid(vulCmdState.FailOnSeverity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.FailOnSeverity, lwseverity.ValidSeverities.String(),
			)
		}
	}

	return nil
}

func vulFailureFlagsEnabled() bool {
	return vulCmdState.FailOnSeverity != "" || vulCmdState.FailOnFixable
}

func vulFiltersEnabled() bool {
	return vulCmdState.Severity != "" || vulCmdState.Fixable
}

// Used to store data for --package output vuln ctr/host
type packageTable struct {
	cveCount         int
	severity         string
	packageName      string
	packageNamespace string
	currentVersion   string
	fixVersion       string
	packageStatus    string
	hostCount        int
	fixes            int
}

type filteredPackageTable struct {
	packages        []packageTable
	totalPackages   int
	totalUnfiltered int
}

func (pt *packageTable) equals(p packageTable) bool {
	return pt.packageName == p.packageName &&
		pt.packageNamespace == p.packageNamespace &&
		pt.currentVersion == p.currentVersion
}
