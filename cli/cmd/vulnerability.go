//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package cmd

import (
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/olekukonko/tablewriter"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"

	"github.com/lacework/go-sdk/api"
)

var (
	vulCmdState = struct {
		// enable poll mechanism for scans status
		Poll bool

		// pollInterval is the time is seconds to wait between polls
		PollInterval time.Duration

		// when enabled we tread the provided sha256 hash as image id
		ImageID bool

		// display extended details about a vulnerability scan/evaluation
		Details bool

		// display only fixable vulnerabilities
		Fixable bool

		// show a list of packages by number of CVEs
		Packages bool

		// start time for listing evaluations
		Start string

		// end time for listing evaluations
		End string
	}{PollInterval: time.Second * 5}

	// vulnerability represents the vulnerability command
	vulnerabilityCmd = &cobra.Command{
		Use:     "vulnerability",
		Aliases: []string{"vuln", "vul"},
		Short:   "view vulnerability evaluations and run on-demand scans",
		Long: `
Request on-demand vulnerability scans and vizualize previous evaluations
from published images.

(*) PREREQUISITE: Your Lacework account should already be configured
with a Container Registry Integration of the container images you are
trying to scan or visualize.

To create a new integration use the following command:

    $ lacework integration create

Or, if you prefer to do it via the WebUI, log in to your account at:

    https://<ACCOUNT>.lacework.net

Then navigate to Settings > Integrations > Container Registry.`,
	}

	// vulScanCmd represents the scan sub-command inside the vulnerability command
	vulScanCmd = &cobra.Command{
		Use:   "scan",
		Short: "manage on-demand vulnerability scans",
		Long: `Request on-demand vulnerability scans and view the generated evaluations.

NOTE: Scans can take up to 15 minutes to return results.`,
	}

	// vulScanRunCmd represents the run sub-command inside the scan vulnerability command
	vulScanRunCmd = &cobra.Command{
		Use:   "run <registry> <repository> <tag|digest>",
		Short: "request an on-demand vulnerability scan",
		Long: `Request an on-demand vulnerability scan.

Arguments:
  <registry>    container registry where the container image has been published
  <repository>  repository name that contains the container image
  <tag|digest>  either a tag or an image digest to scan (digest format: sha256:1ee...1d3b)`,
		Args: cobra.ExactArgs(3),
		RunE: func(_ *cobra.Command, args []string) error {
			cli.Log.Debugw("requesting vulnerability scan",
				"registry", args[0],
				"repository", args[1],
				"tag_or_digest", args[2],
			)
			scan, err := cli.LwApi.Vulnerabilities.Scan(args[0], args[1], args[2])
			if err != nil {
				return errors.Wrap(err, "unable to request on-demand vulnerability scan")
			}

			cli.Log.Debugw("vulnerability scan", "details", scan)
			if !scan.Ok {
				return errors.Errorf(
					"there is a problem with the vulnerability scan: %s",
					scan.Message,
				)
			}

			cli.OutputHuman(
				"A new vulnerability scan has been requested. (request_id: %s)\n\n",
				scan.Data.RequestID,
			)

			if vulCmdState.Poll {
				cli.Log.Infow("tracking scan progress",
					"param", "--poll",
					"request_id", scan.Data.RequestID,
				)
				return pollScanStatus(scan.Data.RequestID)
			}

			if cli.JSONOutput() {
				return cli.OutputJSON(scan.Data)
			}

			cli.OutputHuman("To track the progress of the scan, use the command:\n")
			cli.OutputHuman("  $ lacework vulnerability scan show %s\n", scan.Data.RequestID)
			return nil
		},
	}

	// vulScanShowCmd represents the show sub-command inside the scan vulnerability command
	vulScanShowCmd = &cobra.Command{
		Use:   "show <request_id>",
		Short: "return results about an on-demand vulnerability scan",
		Long:  "Return results about an on-demand vulnerability scan.",
		Args:  cobra.ExactArgs(1),
		RunE: func(_ *cobra.Command, args []string) error {
			if vulCmdState.Poll {
				cli.Log.Infow("tracking scan progress",
					"param", "--poll",
					"request_id", args[0],
				)
				return pollScanStatus(args[0])
			}

			results, err, scanning := checkScanStatus(args[0])
			if err != nil {
				return err
			}

			if cli.JSONOutput() {
				return cli.OutputJSON(results)
			}

			// if the scan is still running, display a nice message
			if scanning {
				cli.OutputHuman(
					"The vulnerability scan is still running. (request_id: %s)\n\n",
					args[0],
				)
				cli.OutputHuman("Use '--poll' to poll until the vulnerability scan completes.\n")
				return nil
			}

			cli.OutputHuman(buildVulnerabilityReport(results))
			return nil
		},
	}
	// vulReportCmd represents the report sub-command inside the vulnerability command
	//
	// TODO: @afiune marking this command as DEPRECATED.
	// TO-BE-REMOVED with issue https://github.com/lacework/go-sdk/issues/162
	vulReportCmd = &cobra.Command{
		Use:   "report <sha256:hash>",
		Short: "(deprecated) use 'evaluation show <sha256:hash>' instead",
		Long: `(DEPRECATED) This command has been moved, use now the following command:

    $ lacework vulnerability evaluation show <sha256:hash>
`,
		Args: cobra.ExactArgs(1),
		RunE: func(_ *cobra.Command, args []string) error {
			cli.OutputHuman("(DEPRECATED) This command has been moved.\n")
			cli.OutputHuman("(DEPRECATED) Use now the command 'lacework vulnerability evaluation show %s'\n\n", args[0])
			return showEvaluationWithSha256(args[0])
		},
	}

	// vulEvaluationCmd represents the evaluation sub-command inside the vulnerability command
	vulEvaluationCmd = &cobra.Command{
		Use:     "evaluation",
		Aliases: []string{"evaluations", "eval"},
		Short:   "review evaluations from assessed container images",
		Long: `Review evaluations from container image scans that run previously either
by the periodic scan mechanism that Lacework runs every hour, or a requested
on-demand vulnerability scan.
`,
	}

	vulEvaluationListCmd = &cobra.Command{
		Use:   "list",
		Short: "list all evaluations from a time range (default last 7 days)",
		Long: `List of images evaluated by the Lacework container vulnerability assessments
during the specified time range, by default this command displays the
evaluations from the last 7 days, but it is possible to specify a different
time range.`,
		Args: cobra.NoArgs,
		RunE: func(_ *cobra.Command, args []string) error {
			var (
				response api.VulContainerEvaluationsResponse
				err      error
			)
			if vulCmdState.Start != "" || vulCmdState.End != "" {
				start, end, errT := parseStartAndEndTime(vulCmdState.Start, vulCmdState.End)
				if errT != nil {
					return errors.Wrap(errT, "unable to parse time range")
				}

				cli.Log.Infow("requesting list of evaluations from custom time range",
					"start_time", start, "end_time", end,
				)
				response, err = cli.LwApi.Vulnerabilities.ListEvaluationsDateRange(start, end)
			} else {
				cli.Log.Info("requesting list of evaluations from the last 7 days")
				response, err = cli.LwApi.Vulnerabilities.ListEvaluations()
			}

			if err != nil {
				return errors.Wrap(err, "unable to get evaluations")
			}

			cli.Log.Debugw("evaluations", "raw", response)
			// Sort the evaluations from the response by date
			sort.Slice(response.Evaluations, func(i, j int) bool {
				return response.Evaluations[i].StartTime.ToTime().After(response.Evaluations[j].StartTime.ToTime())
			})

			if cli.JSONOutput() {
				return cli.OutputJSON(response.Evaluations)
			}

			cli.OutputHuman(vulEvaluationsToTableReport(response.Evaluations))
			return nil
		},
	}

	vulEvaluationShowCmd = &cobra.Command{
		Use:   "show <sha256:hash>",
		Short: "show results of a container image evaluation",
		Long: `Review the results from an evaluation of a container image.

Arguments:
  <sha256:hash> a sha256 hash of a container image (format: sha256:1ee...1d3b)

By default, this command treads the provided sha256 as image digest, when trying to
lookup an evaluation by its image id, provided the flag '--image_id'.

To request an on-demand vulnerability scan:

    $ lacework vulnerability scan run <registry> <repository> <tag|digest>
`,
		Args: cobra.ExactArgs(1),
		RunE: func(_ *cobra.Command, args []string) error {
			return showEvaluationWithSha256(args[0])
		},
	}
)

func init() {
	// add the vulnerability command
	rootCmd.AddCommand(vulnerabilityCmd)

	// add sub-commands to the vulnerability command
	vulnerabilityCmd.AddCommand(vulScanCmd)
	vulnerabilityCmd.AddCommand(vulReportCmd) // TO-BE-REMOVED
	vulnerabilityCmd.AddCommand(vulEvaluationCmd)

	// add sub-commands to the 'vulnerability scan' command
	vulScanCmd.AddCommand(vulScanRunCmd)
	vulScanCmd.AddCommand(vulScanShowCmd)

	// add sub-commands to the 'vulnerability evaluation' command
	vulEvaluationCmd.AddCommand(vulEvaluationListCmd)
	vulEvaluationCmd.AddCommand(vulEvaluationShowCmd)

	// add start flag to evaluation list command
	vulEvaluationListCmd.Flags().StringVar(&vulCmdState.Start,
		"start", "", "start of the time range in UTC (format: yyyy-MM-ddTHH:mm:ssZ)",
	)
	// add end flag to evaluation list command
	vulEvaluationListCmd.Flags().StringVar(&vulCmdState.End,
		"end", "", "end of the time range in UTC (format: yyyy-MM-ddTHH:mm:ssZ)",
	)

	setPollFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
	)

	setDetailsFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
		vulEvaluationShowCmd.Flags(),
	)

	setFixableFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
		vulEvaluationShowCmd.Flags(),
	)

	setPackagesFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
		vulEvaluationShowCmd.Flags(),
	)

	// TO-BE-REMOVED
	vulReportCmd.Flags().BoolVar(
		&vulCmdState.ImageID, "image_id", false,
		"tread the provided sha256 hash as image id",
	)

	vulEvaluationShowCmd.Flags().BoolVar(
		&vulCmdState.ImageID, "image_id", false,
		"tread the provided sha256 hash as image id",
	)
}

func showEvaluationWithSha256(sha string) error {
	var (
		evaluation  api.VulContainerReportResponse
		searchField string
		err         error
	)
	if vulCmdState.ImageID {
		searchField = "image_id"
		cli.Log.Debugw("retrieve image evaluation", searchField, sha)
		evaluation, err = cli.LwApi.Vulnerabilities.ReportFromID(sha)
	} else {
		searchField = "digest"
		cli.Log.Debugw("retrieve image evaluation", searchField, sha)
		evaluation, err = cli.LwApi.Vulnerabilities.ReportFromDigest(sha)
	}
	if err != nil {
		return errors.Wrap(err, "unable to show vulnerability evaluation")
	}

	cli.Log.Debugw("image evaluation", "details", evaluation)
	status := evaluation.CheckStatus()
	switch status {
	case "Success":
		if cli.JSONOutput() {
			return cli.OutputJSON(evaluation.Data)
		}

		cli.OutputHuman(buildVulnerabilityReport(&evaluation.Data))
	case "Unsupported":
		return errors.Errorf(
			`unable to retrieve evaluation for the provided container image. (unsupported distribution)

For more information about supported distributions, visit:
    https://support.lacework.com/hc/en-us/articles/360035472393-Container-Vulnerability-Assessment-Overview
`,
		)
	case "NotFound":
		msg := fmt.Sprintf(
			"unable to find any evaluation from a container image with %s '%s'",
			searchField, sha,
		)

		// add a suggestion to the user in regards of the image_id vs digest
		if !vulCmdState.ImageID {
			msg = fmt.Sprintf("%s\n\n(?) Are you trying to lookup an evaluation using an image id? Try adding '--image_id'", msg)
		}

		return errors.New(msg)
	case "Failed":
		return errors.New(
			"the evaluation failed to execute. Use '--debug' to troubleshoot.",
		)
	default:
		return errors.New(
			"unable to get evaluation status from the container image. Use '--debug' to troubleshoot.",
		)
	}

	return nil
}

func setPollFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Poll, "poll", false,
				fmt.Sprintf("poll until the vulnerability scan completes (%vs intervals)",
					vulCmdState.PollInterval.Seconds()),
			)
		}
	}
}

func setPackagesFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Packages, "packages", false,
				"show a list of packages with CVE count",
			)
		}
	}
}

func setFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Fixable, "fixable", false,
				"display only fixable vulnerabilities",
			)
		}
	}
}

func setDetailsFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Details, "details", false,
				"increase details of an evaluation",
			)
		}
	}
}

func pollScanStatus(requestID string) error {
	cli.StartProgress(" Scan running...")

	for {
		evaluation, err, retry := checkScanStatus(requestID)
		if err != nil {
			return err
		}

		if retry {
			time.Sleep(vulCmdState.PollInterval)
			continue
		}

		if cli.JSONOutput() {
			return cli.OutputJSON(evaluation)
		}

		cli.StopProgress()
		cli.OutputHuman(buildVulnerabilityReport(evaluation))
		return nil
	}
}

func checkScanStatus(requestID string) (*api.VulContainerReport, error, bool) {
	cli.Log.Infow("verifying status of vulnerability scan", "request_id", requestID)
	scan, err := cli.LwApi.Vulnerabilities.ScanStatus(requestID)
	if err != nil {
		return nil, errors.Wrap(err, "unable to verify status of the vulnerability scan"), false
	}

	cli.Log.Debugw("vulnerability scan", "details", scan)
	status := scan.CheckStatus()
	switch status {
	case "Success":
		return &scan.Data, nil, false
	case "Scanning":
		return &scan.Data, nil, true
	case "Unsupported":
		return nil, errors.Errorf(
			`unable to run assessment for the provided container image. (unsupported distribution)

For more information about supported distributions, visit:
    https://support.lacework.com/hc/en-us/articles/360035472393-Container-Vulnerability-Assessment-Overview
`,
		), false
	case "NotFound":
		return nil, errors.Errorf(
			"unable to find any vulnerability scan with request id '%s'",
			requestID,
		), false
	case "Failed":
		return nil, errors.New(
			"the vulnerability scan failed to execute. Use '--debug' to troubleshoot.",
		), false
	default:
		return nil, errors.New(
			"unable to get status from vulnerability scan. Use '--debug' to troubleshoot.",
		), false
	}
}

func buildVulnerabilityReport(report *api.VulContainerReport) string {
	var (
		t                 *tablewriter.Table
		imageDetailsTable = &strings.Builder{}
		vulCountsTable    = &strings.Builder{}
		mainReport        = &strings.Builder{}
	)

	if report.TotalVulnerabilities == 0 {
		return "Great news! This container image has no vulnerabilities.\n"
	}

	t = tablewriter.NewWriter(imageDetailsTable)
	t.SetBorder(false)
	t.SetColumnSeparator("")
	t.SetAlignment(tablewriter.ALIGN_LEFT)
	t.AppendBulk(vulContainerImageToTable(report.Image))
	t.Render()

	t = tablewriter.NewWriter(vulCountsTable)
	t.SetBorder(false)
	t.SetColumnSeparator(" ")
	t.SetHeader([]string{
		"Severity", "Count", "Fixable",
	})
	t.AppendBulk(vulContainerReportToCountsTable(report))
	t.Render()

	t = tablewriter.NewWriter(mainReport)
	t.SetBorder(false)
	t.SetAutoWrapText(false)
	t.SetHeader([]string{
		"Container Image Details",
		"Vulnerabilities",
	})
	t.Append([]string{
		imageDetailsTable.String(),
		vulCountsTable.String(),
	})
	t.Render()

	if vulCmdState.Details || vulCmdState.Fixable || vulCmdState.Packages {
		if vulCmdState.Packages {
			mainReport.WriteString(buildVulnerabilityPackageSummary(report))
			mainReport.WriteString("\n")
		} else {
			mainReport.WriteString(buildVulnerabilityReportDetails(report))
			mainReport.WriteString("\n")
			mainReport.WriteString("Try using '--packages' to show a list of packages with CVE count.\n")
		}
	} else {
		mainReport.WriteString(
			"Try using '--details' to increase details shown about the vulnerability report.\n",
		)
	}

	return mainReport.String()
}

func buildVulnerabilityPackageSummary(report *api.VulContainerReport) string {
	var (
		detailsTable = &strings.Builder{}
		t            = tablewriter.NewWriter(detailsTable)
	)

	t.SetRowLine(false)
	t.SetBorder(false)
	t.SetColumnSeparator(" ")
	t.SetAlignment(tablewriter.ALIGN_LEFT)
	t.SetHeader([]string{
		"CVE Count",
		"Severity",
		"Package",
		"Current Version",
		"Fix Version",
	})
	t.AppendBulk(vulContainerImagePackagesToTable(report.Image))
	t.Render()

	return detailsTable.String()
}

func buildVulnerabilityReportDetails(report *api.VulContainerReport) string {
	var (
		detailsTable = &strings.Builder{}
		t            = tablewriter.NewWriter(detailsTable)
	)

	t.SetRowLine(true)
	t.SetBorders(tablewriter.Border{
		Left:   false,
		Right:  false,
		Top:    true,
		Bottom: true,
	})
	t.SetAlignment(tablewriter.ALIGN_LEFT)
	t.SetHeader([]string{
		"CVE",
		"Severity",
		"Package",
		"Current Version",
		"Fix Version",
		"Introduced in Layer",
	})
	t.AppendBulk(vulContainerImageLayersToTable(report.Image))
	t.Render()

	return detailsTable.String()
}

func vulContainerImagePackagesToTable(image *api.VulContainerImage) [][]string {
	if image == nil {
		return [][]string{}
	}

	out := [][]string{}
	for _, layer := range image.ImageLayers {
		for _, pkg := range layer.Packages {
			for _, vul := range pkg.Vulnerabilities {
				if vulCmdState.Fixable && vul.FixVersion == "" {
					continue
				}

				added := false
				for i := range out {
					if out[i][1] == strings.Title(vul.Severity) &&
						out[i][2] == pkg.Name &&
						out[i][3] == pkg.Version &&
						out[i][4] == vul.FixVersion {

						if count, err := strconv.Atoi(out[i][0]); err == nil {
							out[i][0] = fmt.Sprintf("%d", (count + 1))
							added = true
						}

					}
				}

				if added {
					continue
				}

				out = append(out, []string{
					"1",
					strings.Title(vul.Severity),
					pkg.Name,
					pkg.Version,
					vul.FixVersion,
				})
			}
		}
	}

	// order by severity
	sort.Slice(out, func(i, j int) bool {
		return severityOrder(out[i][1]) < severityOrder(out[j][1])
	})

	return out
}

func vulContainerImageLayersToTable(image *api.VulContainerImage) [][]string {
	if image == nil {
		return [][]string{}
	}

	out := [][]string{}
	for _, layer := range image.ImageLayers {
		for _, pkg := range layer.Packages {
			for _, vul := range pkg.Vulnerabilities {
				if vulCmdState.Fixable && vul.FixVersion == "" {
					continue
				}
				space := regexp.MustCompile(`\s+`)
				createdBy := space.ReplaceAllString(layer.CreatedBy, " ")

				out = append(out, []string{
					vul.Name,
					strings.Title(vul.Severity),
					pkg.Name,
					pkg.Version,
					vul.FixVersion,
					createdBy,
				})
			}
		}
	}

	sort.Slice(out, func(i, j int) bool {
		return severityOrder(out[i][1]) < severityOrder(out[j][1])
	})

	return out
}

func severityOrder(severity string) int {
	switch strings.ToLower(severity) {
	case "critical":
		return 1
	case "high":
		return 2
	case "medium":
		return 3
	case "low":
		return 4
	case "info":
		return 5
	default:
		return 6
	}
}

func vulContainerReportToCountsTable(report *api.VulContainerReport) [][]string {
	return [][]string{
		[]string{"Critical", fmt.Sprint(report.CriticalVulnerabilities),
			fmt.Sprint(report.VulFixableCount("critical"))},
		[]string{"High", fmt.Sprint(report.HighVulnerabilities),
			fmt.Sprint(report.VulFixableCount("high"))},
		[]string{"Medium", fmt.Sprint(report.MediumVulnerabilities),
			fmt.Sprint(report.VulFixableCount("medium"))},
		[]string{"Low", fmt.Sprint(report.LowVulnerabilities),
			fmt.Sprint(report.VulFixableCount("low"))},
		[]string{"Info", fmt.Sprint(report.InfoVulnerabilities),
			fmt.Sprint(report.VulFixableCount("info"))},
	}
}

func vulContainerImageToTable(image *api.VulContainerImage) [][]string {
	if image == nil || image.ImageInfo == nil {
		return [][]string{}
	}

	info := image.ImageInfo
	return [][]string{
		[]string{"ID", info.ImageID},
		[]string{"Digest", info.ImageDigest},
		[]string{"Registry", info.Registry},
		[]string{"Repository", info.Repository},
		[]string{"Size", byteCountBinary(info.Size)},
		[]string{"Created At", info.CreatedTime},
		[]string{"Tags", strings.Join(info.Tags, ",")},
	}
}

func byteCountBinary(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

func vulEvaluationsToTableReport(evaluations []api.VulContainerEvaluation) string {
	var (
		evaluationsTable = &strings.Builder{}
		t                = tablewriter.NewWriter(evaluationsTable)
	)

	t.SetHeader([]string{
		"Registry",
		"Repository",
		"Tags",
		"Last Run",
		"Status",
		"Containers",
		"Vulnerabilities",
		"Image Digest",
	})
	t.SetBorder(false)
	t.AppendBulk(vulEvaluationsToTable(evaluations))
	t.Render()

	return evaluationsTable.String()
}

func vulEvaluationsToTable(evaluations []api.VulContainerEvaluation) [][]string {
	out := [][]string{}
	for _, eval := range evaluations {
		out = append(out, []string{
			eval.ImageRegistry,
			eval.ImageRepo,
			strings.Join(eval.ImageTags, ","),
			eval.StartTime.UTC().Format(time.RFC3339),
			eval.ImageScanStatus,
			eval.NdvContainers,
			vulSummaryFromEvaluation(&eval),
			eval.ImageDigest,
		})
	}
	return out
}

func vulSummaryFromEvaluation(eval *api.VulContainerEvaluation) string {
	summary := []string{}

	summary = addToEvaluationSummary(summary, eval.NumVulnerabilitiesSeverity1, "Critical")
	summary = addToEvaluationSummary(summary, eval.NumVulnerabilitiesSeverity2, "High")
	summary = addToEvaluationSummary(summary, eval.NumVulnerabilitiesSeverity3, "Medium")
	summary = addToEvaluationSummary(summary, eval.NumVulnerabilitiesSeverity4, "Low")
	summary = addToEvaluationSummary(summary, eval.NumVulnerabilitiesSeverity5, "Info")

	if eval.NumFixes != "" {
		summary = append(summary, fmt.Sprintf("%s Fixable", eval.NumFixes))
	}
	return strings.Join(summary, " ")
}

func addToEvaluationSummary(text []string, num, severity string) []string {
	if len(text) == 0 {
		if num != "" && num != "0" {
			return append(text, fmt.Sprintf("%s %s", num, severity))
		}
	}
	return text
}
