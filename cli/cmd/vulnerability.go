//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package cmd

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"

	"github.com/lacework/go-sdk/api"
	"github.com/lacework/go-sdk/internal/array"
)

var (
	vulCmdState = struct {
		// enable poll mechanism for scans status
		Poll bool

		// store the vulnerability assessment in HTML format on disk
		Html bool

		// when enabled we tread the provided sha256 hash as image id
		ImageID bool

		// display extended details about a vulnerability assessment
		Details bool

		// Filter the vulnerability assessment table by severity
		Severity string

		// Exit the CLI application with an error given a specified severity is met
		FailOnSeverity string

		// Exit the CLI application with an error given fixable vulnerabilities
		FailOnFixable bool

		// display only fixable vulnerabilities
		Fixable bool

		// show a list of packages by number of CVEs
		Packages bool

		// start time for listing assessments
		Start string

		// end time for listing assessments
		End string

		// active flag to filter container vulnerability assessments and
		// show only assessments of containers actively running
		Active bool

		// show only hosts that are online
		Online bool

		// show only hosts that are offline
		Offline bool

		// filter assessments for specific repositories
		Repositories []string
	}{}

	// vulnerability represents the vulnerability command that holds both, the host
	// and container sub-commands
	vulnerabilityCmd = &cobra.Command{
		Use:     "vulnerability",
		Aliases: []string{"vuln", "vul"},
		Short:   "container and host vulnerability assessments",
		Long:    "Container and host vulnerability assessments.",
	}

	// vulContainerCmd represents the vulnerability container command
	vulContainerCmd = &cobra.Command{
		Use:     "container",
		Aliases: []string{"ctr"},
		Short:   "vulnerability assessment for containers",
		Long: `Request on-demand container vulnerability scans and show previous assessments
from published images.

(*) PREREQUISITE: Your Lacework account should already be configured
with a Container Registry Integration of the container images you are
trying to scan or show.

To create a new integration use the following command:

    $ lacework integration create

If you prefer to configure the integration via the WebUI, log in to your account at:

    https://<ACCOUNT>.lacework.net

Then navigate to Settings > Integrations > Container Registry.`,
	}

	// vulHostCmd represents the vulnerability host command
	vulHostCmd = &cobra.Command{
		Use:   "host",
		Short: "vulnerability assessment for hosts",
		Long: `Request on-demand host vulnerability scans and show previous assessments
from hosts with the Lacework datacollector agent installed.
`,
	}
)

func init() {
	// add the vulnerability command
	rootCmd.AddCommand(vulnerabilityCmd)

	// add sub-commands to the vulnerability command
	vulnerabilityCmd.AddCommand(vulContainerCmd)
	vulnerabilityCmd.AddCommand(vulHostCmd)
}

func setPollFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Poll, "poll", false, "poll until the vulnerability scan completes")
		}
	}
}

func setPackagesFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Packages, "packages", false,
				"show a list of packages with CVE count",
			)
		}
	}
}

func setFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Fixable, "fixable", false,
				"only show fixable vulnerabilities",
			)
		}
	}
}

func setHtmlFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Html, "html", false,
				"generate a vulnerability assessment in HTML format",
			)
		}
	}
}

func setDetailsFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Details, "details", false,
				"increase details of a vulnerability assessment",
			)
		}
	}
}

func setFailOnSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.FailOnSeverity, "fail_on_severity", "",
				fmt.Sprintf("specify a severity threshold to fail if vulnerabilities are found (%s)",
					strings.Join(api.ValidEventSeverities, ", ")),
			)
		}
	}
}

func setFailOnFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.FailOnFixable, "fail_on_fixable", false,
				"fail if the assessed container has fixable vulnerabilities",
			)
		}
	}
}

func setSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.Severity, "severity", "",
				fmt.Sprintf("filter vulnerability assessment by severity threshold (%s)",
					strings.Join(api.ValidEventSeverities, ", ")),
			)
		}
	}
}

func setActiveFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Active, "active", false,
				"only show vulnerabilities of packages actively running in your environment",
			)
		}
	}
}

func pollScanStatus(requestID string) error {
	cli.StartProgress(" Scan running...")

	var (
		retries      = 0
		start        = time.Now()
		durationTime = start
		expPollTime  = time.Second
		params       = map[string]interface{}{"request_id": requestID}
	)

	// @afiune bug: there are sometimes that the API returns the scan status as
	// successful without any vulnerabilities, as if the assessment had none, but
	// if you query it again, the assessment does have vulnerabilities.
	//
	// JIRA: RAIN-12964
	// Workaround: Retry the polling mechanism twice on success :(
	bugRetry := true
	for {
		retries++
		params["retries"] = retries

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		durationTime = time.Now()

		cli.Event.Feature = featPollCtrScan
		cli.Event.FeatureData = params

		assessment, err, retry := checkScanStatus(requestID)
		if err != nil {
			cli.Event.Error = err.Error()
			cli.SendHoneyvent()
			return err
		}

		if retry {
			cli.Log.Debugw("waiting for a retry", "request_id", requestID, "sleep", expPollTime)
			cli.SendHoneyvent()
			time.Sleep(expPollTime)
			expPollTime = time.Duration(retries*retries) * time.Second
			continue
		}

		// @afiune bug: there are sometimes that the API returns the scan status as
		// successful without any vulnerabilities, as if the assessment had none, but
		// if you query it again, the assessment does have vulnerabilities.
		//
		// JIRA: RAIN-12964
		// Workaround: Retry the polling mechanism twice on success :(
		if bugRetry {
			bugRetry = false
			cli.SendHoneyvent()
			// we do NOT use the exponential polling time here since this is just a
			// workaround and therefore waiting for 5s or so is enough time
			time.Sleep(time.Second * 5)
			continue
		}

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		params["total_duration_ms"] = time.Since(start).Milliseconds()
		cli.Event.FeatureData = params
		cli.SendHoneyvent()

		// reset event fields
		cli.Event.DurationMs = 0
		cli.Event.FeatureData = nil

		cli.StopProgress()

		if err := buildReports(assessment) ; err != nil{
			return err
		}

		if vulFailureFlagsEnabled() {
			cli.Log.Infow("failure flags enabled",
				"fail_on_severity", vulCmdState.FailOnSeverity,
				"fail_on_fixable", vulCmdState.FailOnFixable,
			)
			vulnPolicy := NewVulnerabilityPolicyError(
				assessment,
				vulCmdState.FailOnSeverity,
				vulCmdState.FailOnFixable,
			)
			if vulnPolicy.NonCompliant() {
				return vulnPolicy
			}
		}

		return nil
	}
}

func buildReports(assessment *api.VulnContainerAssessment) error {
	vulnReport := VulnerabilityReport{
		Summary: buildVulnerabilitySummaryReport(assessment),
		Details: vulnerabilityDetailsReport{
			VulnerabilityDetails: filterVulContainerImageLayers(assessment.Image),
			Packages: filterVulnContainerImagePackages(assessment.Image),
		},
	}

	if cli.JSONOutput() {
		if err := cli.OutputJSON(vulnReport); err != nil {
			return err
		}
	} else {
		cli.OutputHuman(buildReportTable(vulnReport))
	}

	if vulCmdState.Html {
		if err := generateVulnAssessmentHTML(assessment); err != nil {
			return err
		}
	}
	return nil
}

func buildVulnerabilitySummaryReport(assessment *api.VulnContainerAssessment) vulnerabilitySummaryReport {
	return vulnerabilitySummaryReport{
		ImageInfo:                   imageInfo{
			ImageDigest: assessment.Image.ImageInfo.ImageDigest,
			ImageID:     assessment.Image.ImageInfo.ImageID,
			Registry:    assessment.Image.ImageInfo.Registry,
			Repository:  assessment.Image.ImageInfo.Repository,
			CreatedTime: assessment.Image.ImageInfo.CreatedTime,
			Size:        assessment.Image.ImageInfo.Size,
			Tags:        assessment.Image.ImageInfo.Tags,
		},
		VulnCounts: vulnCounts{
			TotalVulnerabilities:    assessment.TotalVulnerabilities,
			CriticalVulnerabilities: assessment.CriticalVulnerabilities,
			HighVulnerabilities:     assessment.HighVulnerabilities,
			MediumVulnerabilities:   assessment.MediumVulnerabilities,
			LowVulnerabilities:      assessment.LowVulnerabilities,
			InfoVulnerabilities:     assessment.InfoVulnerabilities,
			FixableVulnCounts: fixableVulnCounts{
				FixableVulns:                   assessment.FixableVulnerabilities,
				FixableCriticalVulnerabilities: assessment.VulnFixableCount("critical"),
				FixableHighVulnerabilities:     assessment.VulnFixableCount("high"),
				FixableMediumVulnerabilities:   assessment.VulnFixableCount("medium"),
				FixableLowVulnerabilities:      assessment.VulnFixableCount("low"),
				FixableInfoVulnerabilities:     assessment.VulnFixableCount("info"),
			},
		},

		LastEvaluationTime:      assessment.LastEvaluationTime,
	}
}

type vulnerabilityDetailsReport struct {
	VulnerabilityDetails filteredImageTable
	Packages filteredPackageTable `json:"-"`
}

type vulnerabilitySummaryReport struct {
	ImageInfo               imageInfo
	VulnCounts				vulnCounts
	LastEvaluationTime      string
}

type imageInfo struct {
	ImageDigest string
	ImageID     string
	Registry    string
	Repository  string
	CreatedTime string
	Size        int64
	Tags        []string
}

type vulnCounts struct  {
	TotalVulnerabilities    int32
	CriticalVulnerabilities int32
	HighVulnerabilities     int32
	MediumVulnerabilities   int32
	LowVulnerabilities      int32
	InfoVulnerabilities     int32
	FixableVulnCounts 		fixableVulnCounts
}

type fixableVulnCounts struct  {
	FixableVulns int32
	FixableCriticalVulnerabilities int32
	FixableHighVulnerabilities     int32
	FixableMediumVulnerabilities   int32
	FixableLowVulnerabilities      int32
	FixableInfoVulnerabilities     int32
}

type VulnerabilityReport struct {
	Summary vulnerabilitySummaryReport
	Details vulnerabilityDetailsReport
}

func buildReportTable(vulnReport VulnerabilityReport) string {
	report := &strings.Builder{}

	report.WriteString(buildVulnerabilityReportTable(vulnReport.Summary))
	if vulCmdState.Details || vulCmdState.Packages || vulFiltersEnabled() {
		report.WriteString(buildVulnerabilityDetailsReportTable(vulnReport.Details))
	}

	return report.String()
}

func checkScanStatus(requestID string) (*api.VulnContainerAssessment, error, bool) {
	cli.Log.Infow("verifying status of vulnerability scan", "request_id", requestID)
	scan, err := cli.LwApi.Vulnerabilities.Container.ScanStatus(requestID)
	if err != nil {
		return nil, errors.Wrap(err, "unable to verify status of the vulnerability scan"), false
	}

	cli.Log.Debugw("vulnerability scan", "details", scan)
	status := scan.CheckStatus()
	switch status {
	case "Success":
		return &scan.Data, nil, false
	case "Scanning":
		return &scan.Data, nil, true
	case "Unsupported":
		return nil, errors.Errorf(
			`unable to run assessment for the provided container image. (unsupported distribution)

For more information about supported distributions, visit:
    https://support.lacework.com/hc/en-us/articles/360035472393-Container-Vulnerability-Assessment-Overview
`,
		), false
	case "NotFound":
		return nil, errors.Errorf(
			"unable to find any vulnerability scan with request id '%s'",
			requestID,
		), false
	case "Failed":
		return nil, errors.New(
			"the vulnerability scan failed to execute. Use '--debug' to troubleshoot.",
		), false
	default:
		return nil, errors.New(
			"unable to get status from vulnerability scan. Use '--debug' to troubleshoot.",
		), false
	}
}

func severityOrder(severity string) int {
	switch strings.ToLower(severity) {
	case "critical":
		return 1
	case "high":
		return 2
	case "medium":
		return 3
	case "low":
		return 4
	case "info":
		return 5
	default:
		return 6
	}
}

func byteCountBinary(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

func stringToInt(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		cli.Log.Debugw("unable to convert string to int",
			"string", s, "error", err.Error(), "func", "stringToInt",
		)
		return 0
	}
	return i
}

func validateSeverityFlags() error {
	if vulCmdState.Severity != "" {
		if !array.ContainsStr(api.ValidEventSeverities, vulCmdState.Severity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.Severity, strings.Join(api.ValidEventSeverities, ", "),
			)
		}
	}

	if vulCmdState.FailOnSeverity != "" {
		if !array.ContainsStr(api.ValidEventSeverities, vulCmdState.FailOnSeverity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.FailOnSeverity, strings.Join(api.ValidEventSeverities, ", "),
			)
		}
	}

	return nil
}

func vulFailureFlagsEnabled() bool {
	return vulCmdState.FailOnSeverity != "" || vulCmdState.FailOnFixable
}

func vulFiltersEnabled() bool {
	return vulCmdState.Severity != "" || vulCmdState.Fixable
}
