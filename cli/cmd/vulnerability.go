//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package cmd

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/lacework/go-sdk/internal/array"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"

	"github.com/lacework/go-sdk/api"
)

var (
	vulCmdState = struct {
		// enable poll mechanism for scans status
		Poll bool

		// store the vulnerability assessment in HTML format on disk
		Html bool

		// when enabled we tread the provided sha256 hash as image id
		ImageID bool

		// display extended details about a vulnerability assessment
		Details bool

		// Filter the vulnerability assessment table by severity
		Severity string

		// Exit the CLI application with an error given a specified severity is met
		FailOnSeverity string

		// Exit the CLI application with an error given fixable vulnerabilities
		FailOnFixable bool

		// display only fixable vulnerabilities
		Fixable bool

		// show a list of packages by number of CVEs
		Packages bool

		// start time for listing assessments
		Start string

		// end time for listing assessments
		End string

		// active flag to filter container vulnerability assessments and
		// show only assessments of containers actively running
		Active bool

		// show only hosts that are online
		Online bool

		// show only hosts that are offline
		Offline bool

		// filter assessments for specific repositories
		Repositories []string
	}{}

	// vulnerability represents the vulnerability command that holds both, the host
	// and container sub-commands
	vulnerabilityCmd = &cobra.Command{
		Use:     "vulnerability",
		Aliases: []string{"vuln", "vul"},
		Short:   "container and host vulnerability assessments",
		Long:    "Container and host vulnerability assessments.",
	}

	// vulContainerCmd represents the vulnerability container command
	vulContainerCmd = &cobra.Command{
		Use:     "container",
		Aliases: []string{"ctr"},
		Short:   "vulnerability assessment for containers",
		Long: `Request on-demand container vulnerability scans and show previous assessments
from published images.

(*) PREREQUISITE: Your Lacework account should already be configured
with a Container Registry Integration of the container images you are
trying to scan or show.

To create a new integration use the following command:

    $ lacework integration create

If you prefer to configure the integration via the WebUI, log in to your account at:

    https://<ACCOUNT>.lacework.net

Then navigate to Settings > Integrations > Container Registry.`,
	}

	// vulHostCmd represents the vulnerability host command
	vulHostCmd = &cobra.Command{
		Use:   "host",
		Short: "vulnerability assessment for hosts",
		Long: `Request on-demand host vulnerability scans and show previous assessments
from hosts with the Lacework datacollector agent installed.
`,
	}

	// TODO: @afiune marking this command as DEPRECATED.
	// ---------------------------------------------------------------------------------------------
	// TO-BE-REMOVED with issue https://github.com/lacework/go-sdk/issues/162
	vulReportCmd = &cobra.Command{
		Use:    "report <sha256:hash>",
		Hidden: true,
		Long: `(DEPRECATED) This command has been moved, use now the following command:

    $ lacework vulnerability container show-assessment <sha256:hash>`,
		Args: cobra.ExactArgs(1),
		RunE: func(_ *cobra.Command, args []string) error {
			cli.OutputHuman("(DEPRECATED) This command has been moved.\n")
			cli.OutputHuman("(DEPRECATED) Use now the command 'lacework vulnerability container show-assessment %s'\n\n", args[0])
			if cli.JSONOutput() {
				cli.Log.Warnw("this command has been deprecated", "moved_to", "lacework vulnerability container show-assessment")
			}
			return showContainerAssessmentsWithSha256(args[0])
		},
	}
	vulScanCmd = &cobra.Command{
		Use:    "scan",
		Hidden: true,
		Long: `(DEPRECATED) This command has been deprecated, look at the command:

    $ lacework vulnerability container --help`,
	}
	vulScanRunCmd = &cobra.Command{
		Use:    "run <registry> <repository> <tag|digest>",
		Hidden: true,
		Long: `(DEPRECATED) This command has been moved, use now the following command:

    $ lacework vulnerability container scan <registry> <repository> <tag|digest>`,
		Args: cobra.ExactArgs(3),
		RunE: func(_ *cobra.Command, args []string) error {
			cli.OutputHuman("(DEPRECATED) This command has been moved.\n")
			cli.OutputHuman(
				"(DEPRECATED) Use now the command 'lacework vulnerability container scan %s %s %s'\n\n",
				args[0], args[1], args[2],
			)
			if cli.JSONOutput() {
				cli.Log.Warnw("this command has been deprecated", "moved_to", "lacework vulnerability container scan")
			}
			return requestOnDemandContainerVulnerabilityScan(args)
		},
	}
	vulScanShowCmd = &cobra.Command{
		Use:    "show <request_id>",
		Hidden: true,
		Long: `(DEPRECATED) This command has been moved, use now the following command:

    $ lacework vulnerability container scan-status <registry> <repository> <tag|digest>`,
		Args: cobra.ExactArgs(1),
		RunE: func(_ *cobra.Command, args []string) error {
			cli.OutputHuman("(DEPRECATED) This command has been moved.\n")
			cli.OutputHuman("(DEPRECATED) Use now the command 'lacework vulnerability container scan-status %s'\n\n", args[0])
			if cli.JSONOutput() {
				cli.Log.Warnw("this command has been deprecated", "moved_to", "lacework vulnerability container scan-status")
			}
			return checkOnDemandContainerVulnerabilityStatus(args[0])
		},
	}
	// END-OF-COMMANDS-TO-BE-REMOVED with issue https://github.com/lacework/go-sdk/issues/162
	// ---------------------------------------------------------------------------------------------
)

func init() {
	// add the vulnerability command
	rootCmd.AddCommand(vulnerabilityCmd)

	// add sub-commands to the vulnerability command
	vulnerabilityCmd.AddCommand(vulContainerCmd)
	vulnerabilityCmd.AddCommand(vulHostCmd)

	// DEPRECATED commands and flags that will be removed with
	// GH Issue https://github.com/lacework/go-sdk/issues/162
	// ---------------------------------------------------------------------------------------------
	vulnerabilityCmd.AddCommand(vulReportCmd) // TO-BE-REMOVED
	vulnerabilityCmd.AddCommand(vulScanCmd)   // TO-BE-REMOVED
	vulScanCmd.AddCommand(vulScanRunCmd)      // TO-BE-REMOVED
	vulScanCmd.AddCommand(vulScanShowCmd)     // TO-BE-REMOVED
	setPollFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
	)
	setDetailsFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
	)
	setFixableFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
	)
	setPackagesFlag(
		vulScanRunCmd.Flags(),
		vulScanShowCmd.Flags(),
		vulReportCmd.Flags(), // TO-BE-REMOVED
	)
	vulReportCmd.Flags().BoolVar(
		&vulCmdState.ImageID, "image_id", false,
		"tread the provided sha256 hash as image id",
	)
	// END-OF-FLAGS-TO-BE-REMOVED with issue https://github.com/lacework/go-sdk/issues/162
	// ---------------------------------------------------------------------------------------------
}

func setPollFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Poll, "poll", false, "poll until the vulnerability scan completes")
		}
	}
}

func setPackagesFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Packages, "packages", false,
				"show a list of packages with CVE count",
			)
		}
	}
}

func setFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Fixable, "fixable", false,
				"only show fixable vulnerabilities",
			)
		}
	}
}

func setHtmlFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Html, "html", false,
				"generate a vulnerability assessment in HTML format",
			)
		}
	}
}

func setDetailsFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Details, "details", false,
				"increase details of a vulnerability assessment",
			)
		}
	}
}

func setFailOnSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.FailOnSeverity, "fail_on_severity", "",
				fmt.Sprintf("specify a severity threshold to fail if vulnerabilities are found (%s)",
					strings.Join(api.ValidEventSeverities, ", ")),
			)
		}
	}
}

func setFailOnFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.FailOnFixable, "fail_on_fixable", false,
				"fail if the assessed container has fixable vulnerabilities (use in conjunction with --fail_on_severity)",
			)
		}
	}
}

func setSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.Severity, "severity", "",
				fmt.Sprintf("filter vulnerability assessment by severity threshold (%s)",
					strings.Join(api.ValidEventSeverities, ", ")),
			)
		}
	}
}

func setActiveFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Active, "active", false,
				"only show vulnerabilities of packages actively running in your environment",
			)
		}
	}
}

func pollScanStatus(requestID string) error {
	cli.StartProgress(" Scan running...")

	var (
		retries      = 0
		start        = time.Now()
		durationTime = start
		expPollTime  = time.Second
		params       = map[string]interface{}{"request_id": requestID}
	)

	// @afiune bug: there are sometimes that the API returns the scan status as
	// successful without any vulnerabilities, as if the assessment had none, but
	// if you query it again, the assessment does have vulnerabilities.
	//
	// JIRA: RAIN-12964
	// Workaround: Retry the polling mechanism twice on success :(
	bugRetry := true
	for {
		retries++
		params["retries"] = retries

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		durationTime = time.Now()

		cli.Event.Feature = featPollCtrScan
		cli.Event.FeatureData = params

		assessment, err, retry := checkScanStatus(requestID)
		if err != nil {
			cli.Event.Error = err.Error()
			cli.SendHoneyvent()
			return err
		}

		if retry {
			cli.Log.Debugw("waiting for a retry", "request_id", requestID, "sleep", expPollTime)
			cli.SendHoneyvent()
			time.Sleep(expPollTime)
			expPollTime = time.Duration(retries*retries) * time.Second
			continue
		}

		// @afiune bug: there are sometimes that the API returns the scan status as
		// successful without any vulnerabilities, as if the assessment had none, but
		// if you query it again, the assessment does have vulnerabilities.
		//
		// JIRA: RAIN-12964
		// Workaround: Retry the polling mechanism twice on success :(
		if bugRetry {
			bugRetry = false
			cli.SendHoneyvent()
			// we do NOT use the exponential polling time here since this is just a
			// workaround and therefore waiting for 5s or so is enough time
			time.Sleep(time.Second * 5)
			continue
		}

		cli.Event.DurationMs = time.Since(durationTime).Milliseconds()
		params["total_duration_ms"] = time.Since(start).Milliseconds()
		cli.Event.FeatureData = params
		cli.SendHoneyvent()

		// reset event fields
		cli.Event.DurationMs = 0
		cli.Event.FeatureData = nil

		if cli.JSONOutput() {
			return cli.OutputJSON(assessment)
		}

		cli.StopProgress()
		cli.OutputHuman(buildVulnerabilityReportTable(assessment))

		if vulCmdState.Html {
			return generateVulnAssessmentHTML(assessment)
		}

		if vulFailureFlagsEnabled() {
			vulnAssess := vulAssessment{
				severityRating:        assessment.HighestSeverity(),
				fixableSeverityRating: assessment.HighestFixableSeverity(),
				fixableVulCount:       assessment.FixableVulnerabilities,
			}
			vulnAssess.validate()
		}

		return nil
	}
}

type vulAssessment struct {
	severityRating        string
	fixableSeverityRating string
	fixableVulCount       int32
}

func (assessment *vulAssessment) validate() {
	severityRating, _ := eventSeverityToProperTypes(assessment.severityRating)
	fixableSeverityRating, _ := eventSeverityToProperTypes(assessment.fixableSeverityRating)
	threshold, _ := eventSeverityToProperTypes(vulCmdState.FailOnSeverity)

	// If only FailOnFixable exit with error code 8
	if vulCmdState.FailOnSeverity == "" && vulCmdState.FailOnFixable && assessment.fixableVulCount > 0 {
		fmt.Println("Fixable")
		exitwithCode(errors.New(fmt.Sprintf("\nFixable vulnerabilities found. Exiting with error code %d\n", 7)), 7)
	}

	if vulCmdState.FailOnFixable && severityRating <= fixableSeverityRating {
		fmt.Println("severity")
		exitwithCode(errors.New(fmt.Sprintf("\nFixable vulnerabilities found with severity threshold \"%s\". Exiting with error code %d\n",
			vulCmdState.FailOnSeverity, 8)), 8)

	}

	if !vulCmdState.FailOnFixable && severityRating <= threshold {
		exitwithCode(errors.New(fmt.Sprintf("\nVulnerabilities found with threshold \"%s\". Exiting with error code %d\n",
			vulCmdState.FailOnSeverity, 9)), 9)
	}
}

func checkScanStatus(requestID string) (*api.VulnContainerAssessment, error, bool) {
	cli.Log.Infow("verifying status of vulnerability scan", "request_id", requestID)
	scan, err := cli.LwApi.Vulnerabilities.Container.ScanStatus(requestID)
	if err != nil {
		return nil, errors.Wrap(err, "unable to verify status of the vulnerability scan"), false
	}

	cli.Log.Debugw("vulnerability scan", "details", scan)
	status := scan.CheckStatus()
	switch status {
	case "Success":
		return &scan.Data, nil, false
	case "Scanning":
		return &scan.Data, nil, true
	case "Unsupported":
		return nil, errors.Errorf(
			`unable to run assessment for the provided container image. (unsupported distribution)

For more information about supported distributions, visit:
    https://support.lacework.com/hc/en-us/articles/360035472393-Container-Vulnerability-Assessment-Overview
`,
		), false
	case "NotFound":
		return nil, errors.Errorf(
			"unable to find any vulnerability scan with request id '%s'",
			requestID,
		), false
	case "Failed":
		return nil, errors.New(
			"the vulnerability scan failed to execute. Use '--debug' to troubleshoot.",
		), false
	default:
		return nil, errors.New(
			"unable to get status from vulnerability scan. Use '--debug' to troubleshoot.",
		), false
	}
}

func severityOrder(severity string) int {
	switch strings.ToLower(severity) {
	case "critical":
		return 1
	case "high":
		return 2
	case "medium":
		return 3
	case "low":
		return 4
	case "info":
		return 5
	default:
		return 6
	}
}

func byteCountBinary(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

func stringToInt(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		cli.Log.Debugw("unable to convert string to int",
			"string", s, "error", err.Error(), "func", "stringToInt",
		)
		return 0
	}
	return i
}

func validateSeverityFlags() error {
	if vulCmdState.Severity != "" {
		if !array.ContainsStr(api.ValidEventSeverities, vulCmdState.Severity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.Severity, strings.Join(api.ValidEventSeverities, ", "),
			)
		}
	}

	if vulCmdState.FailOnSeverity != "" {
		if !array.ContainsStr(api.ValidEventSeverities, vulCmdState.FailOnSeverity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.FailOnSeverity, strings.Join(api.ValidEventSeverities, ", "),
			)
		}
	}

	return nil
}

func vulFailureFlagsEnabled() bool {
	return vulCmdState.FailOnSeverity != "" || vulCmdState.FailOnFixable
}

func vulFiltersEnabled() bool {
	return vulCmdState.Severity != "" || vulCmdState.Fixable
}
