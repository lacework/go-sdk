//go:build vulnerability

// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"regexp"
	"testing"

	"github.com/stretchr/testify/assert"
)

const (
	registry        = "index.docker.io"
	dirtyRepository = "techallylw/test-cli-dirty"
)

func TestContainerVulnerabilityCommandAliases(t *testing.T) {
	out, err, exitcode := LaceworkCLI("help", "vulnerability", "container")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	out, err, exitcode = LaceworkCLI("help", "vulnerability", "ctr")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandListRegistries(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-registries")
	assert.Contains(t, out.String(), "CONTAINER REGISTRIES",
		"STDOUT table headers changed, please check")
	// we must always have a container registry integration with the registry defined above
	assert.Contains(t, out.String(), registry,
		"STDOUT table does not contain the test container registry, please check")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandListAssessments(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments")
	expectedHeaders := []string{
		"REGISTRY",
		"REPOSITORY",
		"LAST SCAN",
		"STATUS",
		"CONTAINERS",
		"VULNERABILITIES",
		"IMAGE DIGEST",
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	// verify that at least our lacework-cli container is listed
	expectedFields := []string{
		registry,
		dirtyRepository,
		"Success", // status
		"sha256:", // image digest
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, field := range expectedFields {
			assert.Contains(t, out.String(), field,
				"STDOUT table does not contain the '"+field+"' field")
		}
	})
}

func TestContainerVulnerabilityCommandListAssessmentsJson(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments", "--json")
	expectedJsonKeys := []string{
		"eval_guid",
		"eval_status",
		"eval_type",
		"image_created_time",
		"image_digest",
		"image_id",
		"image_namespace",
		"image_registry",
		"image_repo",
		"image_scan_error_msg",
		"image_scan_status",
		"image_scan_time",
		"image_size",
		"image_tags",
		"ndv_containers",
		"num_fixes",
		"num_vulnerabilities_severity_1",
		"num_vulnerabilities_severity_2",
		"num_vulnerabilities_severity_3",
		"num_vulnerabilities_severity_4",
		"num_vulnerabilities_severity_5",
		"start_time",
	}
	t.Run("verify json keys", func(t *testing.T) {
		for _, header := range expectedJsonKeys {
			assert.Contains(t, out.String(), header,
				"STDOUT json keys changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	expectedFields := []string{
		registry,
		dirtyRepository,
		"Success", // status
		"sha256:", // image digest
	}
	t.Run("verify json fields", func(t *testing.T) {
		for _, field := range expectedFields {
			assert.Contains(t, out.String(), field,
				"STDOUT json output does not contain the '"+field+"' field")
		}
	})
}

func TestContainerVulnerabilityCommandListAssessmentsFilterRegistry(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments", "--registry", "index.docker.io")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	expected := "index.docker.io"
	notExpected := "gcr.io"

	assert.Contains(t, out.String(), expected, "STDOUT table does not contain the '"+expected+"' field")
	assert.NotContains(t, out.String(), notExpected, "STDOUT table should not contain the '"+notExpected+"' field")
}

func TestContainerVulnerabilityCommandScanErrorRegistryNotFound(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "container", "scan", "my.registry.example.com", "foo", "bar",
	)
	assert.Empty(t, out.String(),
		"STDOUT should be empty")
	assert.Contains(t, err.String(),
		"container registry 'my.registry.example.com' not found",
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		"Your account has the following container registries configured",
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		fmt.Sprintf("> %s", registry),
		"STDERR mismatch, please check")
	assert.Equal(t, 1, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandScanErrorContainerImageNotFound(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "container", "scan", registry, "foo", "bar",
	)
	assert.Empty(t, out.String(),
		"STDOUT should be empty")
	assert.Contains(t, err.String(),
		fmt.Sprintf("container image 'foo@bar' not found in registry '%s'.", registry),
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		"To view all container registries configured in your account use the command",
		"STDERR mismatch, please check")
	assert.Equal(t, 1, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandScan(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "container", "scan", registry, dirtyRepository, "latest")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
	assert.Contains(t, out.String(), "A new vulnerability scan has been requested. (request_id:",
		"STDOUT changed, please check")
}

func _TestContainerVulnerabilityCommandScanHumanReadablePollGenerateHtml(t *testing.T) {
	// create a temporal directory to check that the HTML file is deployed
	home := createTOMLConfigFromCIvars()
	defer os.RemoveAll(home)
	out, err, exitcode := LaceworkCLIWithHome(home,
		"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--poll", "--html")

	assert.Contains(t, out.String(), "A new vulnerability scan has been requested. (request_id:",
		"STDOUT changed, please check")
	assert.Contains(t, out.String(), "The container vulnerability assessment was stored at 'techallylw-test-cli-dirty-sha256",
		"STDOUT changed, please check")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	t.Run("assert that HTML file was generated", func(t *testing.T) {
		var (
			m           = regexp.MustCompile(`sha256:([0-9a-z])+`)
			shas        = m.FindAllString(out.String(), -1)
			imageDigest = shas[len(shas)-1]
		)
		assert.NotEmpty(t, imageDigest, "unable to extract image digest")
		htmlFile := path.Join(home, fmt.Sprintf("techallylw-test-cli-dirty-%s.html", imageDigest))
		assert.FileExists(t, htmlFile, "the HTML file was not generated")
		storeFileInCircleCI(htmlFile)
	})
}

type containerVulnerabilityScan struct {
	RequestID string `json:"requestId"`
	Status    string `json:"status"`
}

func _TestContainerVulnerabilityCommandsEndToEnd(t *testing.T) {
	var (
		out      bytes.Buffer
		err      bytes.Buffer
		exitcode int
		vulScan  containerVulnerabilityScan
	)
	// we are expecting the following output
	// {
	//   "requestId": "e94f2774-5662-4510-8ebf-2d5e3cd317f6",
	//   "status": "Scanning"
	// }
	t.Run(fmt.Sprintf("run scan for %s/%s", registry, dirtyRepository), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--json")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	t.Run("inspecting json output", func(t *testing.T) {
		errJson := json.Unmarshal(out.Bytes(), &vulScan)
		assert.Nil(t, errJson)
		assert.Equal(t, vulScan.Status, "Scanning",
			"Check JSON scan status")
	})

	// check the on-demand scan status
	t.Run(fmt.Sprintf("check scan status id %s", vulScan.RequestID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan-status", vulScan.RequestID)
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
		assert.Contains(t, out.String(),
			fmt.Sprintf("The vulnerability scan is still running. (request_id: %s)", vulScan.RequestID),
			"STDOUT changed, please check")
		assert.Contains(t, out.String(), "Use '--poll' to poll until the vulnerability scan completes.",
			"STDOUT changed, please check")
	})

	// check the on-demand scan status and poll until it finishes
	t.Run(fmt.Sprintf("polling scan status id %s", vulScan.RequestID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan-status", vulScan.RequestID, "--poll")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	scanStatusOutput := out.String()
	expectedOutput := []string{
		// headers
		"CONTAINER IMAGE DETAILS",
		"VULNERABILITIES",
		"SEVERITY",
		"COUNT",
		"FIXABLE",

		// fields
		"Registry    " + registry,
		"Repository  " + dirtyRepository,
		"Tags        " + "latest",
		"Size",
		"ID",
		"Digest",
		"Critical",
		"High",
		"Medium",
		"Low",
		"Info",
	}
	t.Run("verifying table headers", func(t *testing.T) {
		for _, str := range expectedOutput {
			assert.Contains(t, scanStatusOutput, str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, scanStatusOutput, "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs changed, please update")
	})

	// extract the image id
	m := regexp.MustCompile(`sha256:([0-9a-z])+`)
	imageID := m.FindString(scanStatusOutput)
	assert.NotEmpty(t, imageID, "unable to extract image id")

	// show the results of the on-demand assessment we just ran
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		showAssessmentOutput := out.String()
		assert.Contains(t, scanStatusOutput, showAssessmentOutput,
			"STDOUT from scan-status and show-assessment are not the same")
	})

	// filtered assessment output should be output when a filter is applied
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--severity", "low")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		showAssessmentOutput := out.String()
		assert.Contains(t, showAssessmentOutput, "vulnerabilities showing",
			"Filtered assessment output should contain filtered result ")
	})

	// filtered assessment with packages flag output should be output when a filter is applied
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--severity", "low", "--packages")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		showAssessmentOutput := out.String()
		assert.Contains(t, showAssessmentOutput, "packages showing",
			"Filtered assessment with packages flag output should contain filtered result ")
	})

	// render an HTML file using the show-assessment command
	t.Run("render HTML file using show-assessment command", func(t *testing.T) {
		// create a temporal directory to check that the HTML file is deployed
		home := createTOMLConfigFromCIvars()
		defer os.RemoveAll(home)
		out, err, exitcode = LaceworkCLIWithHome(home,
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--html")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
		assert.Contains(t, out.String(), "The container vulnerability assessment was stored at 'techallylw-test-cli-dirty-sha256",
			"STDOUT changed, please check")

		assert.NotContains(t, out.String(), "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs should not be displayed")

		t.Run("assert that HTML file was generated", func(t *testing.T) {
			var (
				m           = regexp.MustCompile(`sha256:([0-9a-z])+`)
				shas        = m.FindAllString(out.String(), -1)
				imageDigest = shas[len(shas)-1]
			)
			assert.NotEmpty(t, imageDigest, "unable to extract image digest")
			htmlFile := path.Join(home, fmt.Sprintf("techallylw-test-cli-dirty-%s.html", imageDigest))
			assert.FileExists(t, htmlFile, "the HTML file was not generated")
			storeFileInCircleCI(htmlFile)
		})
	})

	// Given fail_on_severity is set, when the vuln threshold is met, then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--fail_on_severity", "high")

		// CLI should terminate with exit code 9
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR ENFORCE POLICY: vulnerabilities found with threshold 'high' (exit code: 9)",
			"STDERR doesn't match")
	})

	// Given fail_on_fixable is set, when the vuln threshold is met and result if fixable, then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity with fixable", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--fail_on_severity", "high", "--fail_on_fixable")

		// CLI should terminate with exit code 9
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR ENFORCE POLICY: fixable vulnerabilities found with threshold 'high' (exit code: 9)",
			"STDERR doesn't match")
	})

	// Given fail_on_fixable is set and json output flag, when any fixable vulns are found then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity with fixable", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--fail_on_fixable", "--json")

		// CLI should terminate with exit code 9
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR ENFORCE POLICY: fixable vulnerabilities found (exit code: 9)",
			"STDERR doesn't match")
	})

	// filtering by severity critical with json flag should filter the json output
	t.Run("test container vulnerability filter severity with json output", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--severity", "critical", "--json")
		severities := []string{"\"severity\": 2", "\"severity\": 3", "\"severity\": 4", "\"severity\": 5"}
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
		assert.NotContains(t, severities, out.String(),
			"Json output does not adhere to severity filter")
	})
}
