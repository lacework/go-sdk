//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"regexp"
	"testing"

	"github.com/stretchr/testify/assert"
)

const (
	registry   = "index.docker.io"
	repository = "lacework/lacework-cli"
	tag1       = "ubuntu-1804"
	tag2       = "amazonlinux-2"
)

func TestContainerVulnerabilityCommandAliases(t *testing.T) {
	out, err, exitcode := LaceworkCLI("help", "vulnerability", "container")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	out, err, exitcode = LaceworkCLI("help", "vulnerability", "ctr")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandListAssessments(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments")
	expectedHeaders := []string{
		"REGISTRY",
		"REPOSITORY",
		"LAST SCAN",
		"STATUS",
		"CONTAINERS",
		"VULNERABILITIES",
		"IMAGE DIGEST",
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	// verify that at least our lacework-cli container is listed
	expectedFields := []string{
		registry,
		repository,
		"Success", // status
		"sha256:", // image digest
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, field := range expectedFields {
			assert.Contains(t, out.String(), field,
				"STDOUT table does not contain the '"+field+"' field")
		}
	})
}

func TestContainerVulnerabilityCommandScanHumanReadablePollGenerateHtml(t *testing.T) {
	// create a temporal directory to check that the HTML file is deployed
	home := createTOMLConfigFromCIvars()
	defer os.RemoveAll(home)
	out, err, exitcode := LaceworkCLIWithHome(home,
		"vulnerability", "container", "scan", registry, repository, tag2, "--poll", "--html")

	assert.Contains(t, out.String(), "A new vulnerability scan has been requested. (request_id:",
		"STDOUT changed, please check")
	assert.Contains(t, out.String(), "The container vulnerability assessment was stored at 'lacework-lacework-cli-sha256",
		"STDOUT changed, please check")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	t.Run("assert that HTML file was generated", func(t *testing.T) {
		var (
			m           = regexp.MustCompile(`sha256:([0-9a-z])+`)
			shas        = m.FindAllString(out.String(), -1)
			imageDigest = shas[len(shas)-1]
		)
		assert.NotEmpty(t, imageDigest, "unable to extract image digest")
		htmlFile := path.Join(home, fmt.Sprintf("lacework-lacework-cli-%s.html", imageDigest))
		assert.FileExists(t, htmlFile, "the HTML file was not generated")
		storeFileInCircleCI(htmlFile)
	})
}

type containerVulnerabilityScan struct {
	RequestID string `json:"requestId"`
	Status    string `json:"status"`
}

func TestContainerVulnerabilityCommandsEndToEnd(t *testing.T) {
	var (
		out      bytes.Buffer
		err      bytes.Buffer
		exitcode int
		vulScan  containerVulnerabilityScan
	)
	// we are expecting the following output
	// {
	//   "requestId": "e94f2774-5662-4510-8ebf-2d5e3cd317f6",
	//   "status": "Scanning"
	// }
	t.Run(fmt.Sprintf("run scan for %s/%s:%s", registry, repository, tag1), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan", registry, repository, tag1, "--json")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	t.Run("inspecting json output", func(t *testing.T) {
		errJson := json.Unmarshal(out.Bytes(), &vulScan)
		assert.Nil(t, errJson)
		assert.Equal(t, vulScan.Status, "Scanning",
			"Check JSON scan status")
	})

	// check the on-demand scan status
	t.Run(fmt.Sprintf("check scan status id %s", vulScan.RequestID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan-status", vulScan.RequestID)
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
		assert.Contains(t, out.String(),
			fmt.Sprintf("The vulnerability scan is still running. (request_id: %s)", vulScan.RequestID),
			"STDOUT changed, please check")
		assert.Contains(t, out.String(), "Use '--poll' to poll until the vulnerability scan completes.",
			"STDOUT changed, please check")
	})

	// check the on-demand scan status and poll until it finishes
	t.Run(fmt.Sprintf("polling scan status id %s", vulScan.RequestID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan-status", vulScan.RequestID, "--poll")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	scanStatusOutput := out.String()
	expectedOutput := []string{
		// headers
		"CONTAINER IMAGE DETAILS",
		"VULNERABILITIES",
		"SEVERITY",
		"COUNT",
		"FIXABLE",

		// fields
		"Registry    " + registry,
		"Repository  " + repository,
		"Tags        " + tag1,
		"Size",
		"ID",
		"Digest",
		"Critical",
		"High",
		"Medium",
		"Low",
		"Info",
	}
	t.Run("verifying table headers", func(t *testing.T) {
		for _, str := range expectedOutput {
			assert.Contains(t, scanStatusOutput, str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, scanStatusOutput, "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs changed, please update")
	})

	// extract the image id
	m := regexp.MustCompile(`sha256:([0-9a-z])+`)
	imageID := m.FindString(scanStatusOutput)
	assert.NotEmpty(t, imageID, "unable to extract image id")

	// show the results of the on-demand assessment we just ran
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		showAssessmentOutput := out.String()
		assert.Contains(t, scanStatusOutput, showAssessmentOutput,
			"STDOUT from scan-status and show-assessment are not the same")
	})

	// render an HTML file using the show-assessment command
	t.Run("render HTML file using show-assessment command", func(t *testing.T) {
		// create a temporal directory to check that the HTML file is deployed
		home := createTOMLConfigFromCIvars()
		defer os.RemoveAll(home)
		out, err, exitcode = LaceworkCLIWithHome(home,
			"vulnerability", "container", "show-assessment", imageID, "--image_id", "--html")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
		assert.Contains(t, out.String(), "The container vulnerability assessment was stored at 'lacework-lacework-cli-sha256",
			"STDOUT changed, please check")

		assert.NotContains(t, out.String(), "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs should not be displayed")

		t.Run("assert that HTML file was generated", func(t *testing.T) {
			var (
				m           = regexp.MustCompile(`sha256:([0-9a-z])+`)
				shas        = m.FindAllString(out.String(), -1)
				imageDigest = shas[len(shas)-1]
			)
			assert.NotEmpty(t, imageDigest, "unable to extract image digest")
			htmlFile := path.Join(home, fmt.Sprintf("lacework-lacework-cli-%s.html", imageDigest))
			assert.FileExists(t, htmlFile, "the HTML file was not generated")
			storeFileInCircleCI(htmlFile)
		})
	})
}
