//go:build vulnerability

//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020-2023, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package integration

import (
	"bytes"
	"fmt"
	"os"
	"path"
	"regexp"
	"testing"

	"github.com/stretchr/testify/assert"
)

const (
	registry        = "index.docker.io"
	dirtyRepository = "techallylw/test-cli-dirty"
)

func TestContainerVulnerabilityCommandAliases(t *testing.T) {
	out, err, exitcode := LaceworkCLI("help", "vulnerability", "container")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	out, err, exitcode = LaceworkCLI("help", "vulnerability", "ctr")
	assert.Contains(t, out.String(), "lacework vulnerability container [command]")
	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandListRegistries(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-registries")
	assert.Contains(t, out.String(), "CONTAINER REGISTRIES",
		"STDOUT table headers changed, please check")
	// we must always have a container registry integration with the registry defined above
	assert.Contains(t, out.String(), registry,
		"STDOUT table does not contain the test container registry, please check")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandListAssessments(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments")
	expectedHeaders := []string{
		"REGISTRY",
		"REPOSITORY",
		"LAST SCAN",
		"CONTAINERS",
		"STATUS",
		"VULNERABILITIES",
		"IMAGE DIGEST",
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	// verify that at least our lacework-cli container is listed
	expectedFields := []string{
		registry,
		dirtyRepository,
		"Success", // status
		"sha256:", // image digest
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, field := range expectedFields {
			assert.Contains(t, out.String(), field,
				"STDOUT table does not contain the '"+field+"' field")
		}
	})
}

func TestContainerVulnerabilityCommandListAssessmentsJson(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments", "--json")
	expectedJsonKeys := []string{
		"digest",
		"image_id",
		"registry",
		"repository",
		"scan_status",
		"scan_time",
		"cves",
		"fixable",
		"package_name",
		"severity",
		"vuln_id",
	}
	t.Run("verify json keys", func(t *testing.T) {
		for _, header := range expectedJsonKeys {
			assert.Contains(t, out.String(), header,
				"STDOUT json keys changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	expectedFields := []string{
		registry,
		dirtyRepository,
		"Success", // status
		"sha256:", // image digest
	}
	t.Run("verify json fields", func(t *testing.T) {
		for _, field := range expectedFields {
			assert.Contains(t, out.String(), field,
				"STDOUT json output does not contain the '"+field+"' field")
		}
	})
}

func TestContainerVulnerabilityCommandListAssessmentsRegistryNotFound(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments",
		"--registry", "bubu", "--noninteractive")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
	assert.Contains(t, out.String(),
		"There are no assessments for the specified registry in your environment.",
		"something changed in this error message?")
}

func TestContainerVulnerabilityCommandListAssessmentsFilterRegistry(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "container", "list-assessments",
		"--registry", "index.docker.io")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	expected := "index.docker.io"
	notExpected := "gcr.io"

	assert.Contains(t, out.String(), expected, "STDOUT table does not contain the '"+expected+"' field")
	assert.NotContains(t, out.String(), notExpected, "STDOUT table should not contain the '"+notExpected+"' field")
}

func TestContainerVulnerabilityCommandScanErrorRegistryNotFound(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "container", "scan", "my.registry.example.com", "foo", "bar",
	)
	assert.Empty(t, out.String(),
		"STDOUT should be empty")
	assert.Contains(t, err.String(),
		"container registry 'my.registry.example.com' not found",
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		"Your account has the following container registries configured",
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		fmt.Sprintf("> %s", registry),
		"STDERR mismatch, please check")
	assert.Equal(t, 1, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandScanErrorContainerImageNotFound(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "container", "scan", registry, "foo", "bar",
	)
	assert.Empty(t, out.String(),
		"STDOUT should be empty")
	assert.Contains(t, err.String(),
		fmt.Sprintf("container image 'foo@bar' not found in registry '%s'.", registry),
		"STDERR mismatch, please check")
	assert.Contains(t, err.String(),
		"To view all container registries configured in your account use the command",
		"STDERR mismatch, please check")
	assert.Equal(t, 1, exitcode,
		"EXITCODE is not the expected one")
}

func TestContainerVulnerabilityCommandScanFailOnSeverity(t *testing.T) {
	home := createTOMLConfigFromCIvars()
	defer os.RemoveAll(home)
	_, err, exitcode := LaceworkCLIWithHome(home,
		"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--poll", "--fail_on_severity", "high")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): vulnerabilities found with threshold 'high' (exit code: 9)",
		"STDERR doesn't match")
}

func TestContainerVulnerabilityCommandScanFailOnFixable(t *testing.T) {
	home := createTOMLConfigFromCIvars()
	defer os.RemoveAll(home)
	_, err, exitcode := LaceworkCLIWithHome(home,
		"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--poll", "--fail_on_fixable")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): fixable vulnerabilities found (exit code: 9)",
		"STDERR doesn't match")
}

func TestContainerVulnerabilityCommandScanHumanReadablePollGenerateHtml(t *testing.T) {
	// create a temporal directory to check that the HTML file is deployed
	home := createTOMLConfigFromCIvars()
	defer os.RemoveAll(home)
	out, err, exitcode := LaceworkCLIWithHome(home,
		"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--poll", "--html")

	assert.Contains(t, out.String(), "A new vulnerability scan has been requested. (request_id:",
		"STDOUT changed, please check")
	assert.Contains(t, out.String(), "The container vulnerability assessment was stored at 'techallylw-test-cli-dirty-sha256",
		"STDOUT changed, please check")
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	t.Run("assert that HTML file was generated", func(t *testing.T) {
		var (
			m           = regexp.MustCompile(`sha256:([0-9a-z])+`)
			shas        = m.FindAllString(out.String(), -1)
			imageDigest = shas[len(shas)-1]
		)
		assert.NotEmpty(t, imageDigest, "unable to extract image digest")
		htmlFile := path.Join(home, fmt.Sprintf("techallylw-test-cli-dirty-%s.html", imageDigest))
		assert.FileExists(t, htmlFile, "the HTML file was not generated")
		storeFileInCircleCI(htmlFile)
	})
}

type containerVulnerabilityScan struct {
	RequestID string `json:"requestId"`
	Status    string `json:"status"`
}

// Unstable test disabled as part of GROW-1396
func TestContainerVulnerabilityCommandsEndToEnd(t *testing.T) {
	t.Parallel()
	var (
		out      bytes.Buffer
		err      bytes.Buffer
		exitcode int
	)
	t.Run(fmt.Sprintf("run scan for %s/%s", registry, dirtyRepository), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "scan", registry, dirtyRepository, "latest", "--poll", "--details")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	scanOutput := out.String()
	expectedOutput := []string{
		// headers
		"CONTAINER IMAGE DETAILS",
		"VULNERABILITIES",
		"SEVERITY",
		"COUNT",
		"FIXABLE",

		// fields
		"Registry    " + registry,
		"Repository  " + dirtyRepository,
		"Tags        " + "latest",
		"Size",
		"ID",
		"Digest",
		"Critical",
		"High",
		"Medium",
		"Low",
		"Info",
	}

	assert.NotContains(t, out.String(), "GOOD",
		"STDOUT should not have vulnerabilities with status 'GOOD'")

	t.Run("inspecting summary scan output/table", func(t *testing.T) {
		assert.Contains(t, scanOutput,
			"A new vulnerability scan has been requested. (request_id:",
			"Check JSON scan status")
		for _, str := range expectedOutput {
			assert.Contains(t, scanOutput, str,
				"STDOUT table does not contain the '"+str+"' output")
		}
	})

	// extract the image id
	m := regexp.MustCompile(`sha256:([0-9a-z])+`)
	imageID := m.FindString(scanOutput)
	assert.NotEmpty(t, imageID, "unable to extract image id")

	// show the results of the on-demand assessment we just ran
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--image_id")
		// Deprecated flag
		assert.Contains(t, err.String(),
			"Flag --image_id has been deprecated, by default we now look up both, image_id and image_digest at once.",
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		for _, str := range expectedOutput {
			assert.Contains(t, out.String(), str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, out.String(),
			"Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs changed, please update")
	})

	// filtered assessment output should be output when a filter is applied,
	// also, we are skipping the deprecated flag '--image_id'
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--severity", "low")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		for _, str := range expectedOutput {
			assert.Contains(t, out.String(), str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, out.String(),
			"Try adding '--packages' to show a list of packages with CVE count.",
			"STDOUT breadcrumbs changed, please update")
	})

	// filtered assessment with packages flag output should be output when a filter is applied,
	// also, we are skipping the deprecated flag '--image_id'
	t.Run(fmt.Sprintf("test show-assessment of image id %s", imageID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--severity", "low", "--packages")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		for _, str := range expectedOutput {
			assert.Contains(t, out.String(), str,
				"STDOUT table does not contain the '"+str+"' output")
		}
	})

	// Given fail_on_severity is set, when the vuln threshold is met, then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--fail_on_severity", "high")

		// CLI should terminate with exit code 9
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR (FAIL-ON): vulnerabilities found with threshold 'high' (exit code: 9)",
			"STDERR doesn't match")
	})

	// Given fail_on_fixable is set, when the vuln threshold is met and
	// result if fixable, then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity with fixable", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID,
			"--fail_on_severity", "high", "--fail_on_fixable")

		// CLI should terminate with exit code 9
		// NOTE @afiune This is NOT working properly, the problem is coming from the func
		// HighestFixableSeverity() inside the VulnerabilitiesContainersResponse struct
		//
		// FIX IT https://lacework.atlassian.net/browse/GROW-1388
		//
		// assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		// assert.Contains(t, err.String(),
		// "ERROR (FAIL-ON): fixable vulnerabilities found with threshold 'high' (exit code: 9)",
		// "STDERR doesn't match")
	})

	// Given fail_on_fixable is set and json output flag, when any fixable vulns are found
	// then the exit code should be 9
	t.Run("test container vulnerability fail_on_severity with fixable", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "container", "show-assessment", imageID, "--fail_on_fixable", "--json")

		// CLI should terminate with exit code 9
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR (FAIL-ON): fixable vulnerabilities found (exit code: 9)",
			"STDERR doesn't match")
	})

	// filtering by severity critical with json flag should filter the json output
	//
	// NOTE @afiune this also does not work, we get all severities even with the filter
	//
	// FIX IT https://lacework.atlassian.net/browse/GROW-1388
	//
	// t.Run("test container vulnerability filter severity with json output", func(t *testing.T) {
	// out, err, exitcode = LaceworkCLIWithTOMLConfig(
	// "vulnerability", "container", "show-assessment", imageID, "--severity", "critical", "--json")
	// severities := []string{"\"severity\": 2", "\"severity\": 3", "\"severity\": 4", "\"severity\": 5"}
	// assert.Empty(t,
	// err.String(),
	// "STDERR should be empty")
	// assert.Equal(t, 0, exitcode,
	// "EXITCODE is not the expected one")
	// assert.NotContains(t, severities, out.String(),
	// "Json output does not adhere to severity filter")
	// })
}
