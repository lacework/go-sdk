//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"runtime"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/lacework/go-sdk/api"
)

// persistent host "ip-10-0-1-170.us-west-2.compute.internal"
// NOTE: host will need to be updated "circle-ci-test-node" when RAIN-13990 is resolved
// managed by TF: github.com/lacework-dev/tech-ally-ci-environment
var (
	machineID = "30"
	hostname  = "circle-ci-test-node"
)

func TestHostVulnerabilityCommandListCves(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves")
	expectedHeaders := []string{
		"CVE",
		"SEVERITY",
		"SCORE",
		"PACKAGE",
		"CURRENT VERSION",
		"FIX VERSION",
		"OS VERSION",
		"HOSTS",
		"PKG STATUS",
		"VULN STATUS",
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	assert.Contains(t, out.String(),
		"Try adding '--active' to only show vulnerabilities of packages actively running.",
		"STDOUT breadcrumbs changed, please update")
}

func TestHostVulnerabilityCommandsEndToEnd(t *testing.T) {
	var (
		out          bytes.Buffer
		err          bytes.Buffer
		exitcode     int
		hostVulnCVEs []api.HostVulnCVE
	)
	t.Run("list-cves", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "host", "list-cves", "--json")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	t.Run("inspecting json output", func(t *testing.T) {
		errJson := json.Unmarshal(out.Bytes(), &hostVulnCVEs)
		assert.Nil(t, errJson)
		assert.NotEmpty(t, hostVulnCVEs, "check JSON list-cves response")
	})

	cveID := hostVulnCVEs[0].ID
	t.Run(fmt.Sprintf("list-hosts for CVE '%s'", cveID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "host", "list-hosts", cveID)
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		expectedHeaders := []string{
			"MACHINE ID",
			"HOSTNAME",
			"EXTERNAL IP",
			"INTERNAL IP",
			"OS/ARCH",
			"PROVIDER",
			"INSTANCE ID",
			"VULNERABILITIES",
			"STATUS",
		}
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
}

func TestHostVulnerabilityCommandShowAssessment(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "show-assessment", machineID)
	expectedOutput := []string{
		// headers
		"HOST DETAILS",
		"VULNERABILITIES",
		"SEVERITY",
		"COUNT",
		"FIXABLE",

		// fields
		"Machine ID   " + machineID,
		// @afiune this test is very lacky, it fails some times
		// https://github.com/lacework/go-sdk/issues/261
		"Hostname     " + hostname,
		"Os           linux",
		"Arch         amd64",
		"External IP",
		"Internal IP",
		"Namespace",
		"Provider",
		"Instance ID",
		"AMI",

		// severities
		"Critical",
		"High",
		"Medium",
		"Low",
		"Info",
	}
	t.Run("verifying table headers", func(t *testing.T) {
		for _, str := range expectedOutput {
			assert.Contains(t, out.String(), str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, out.String(), "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs changed, please update")
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
}

func TestHostVulnerabilityCommandGeneratePkgManifest(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "generate-pkg-manifest")

	if runtime.GOOS == "linux" {
		assert.Contains(t, out.String(), "os_pkg_info_list",
			"STDOUT does not contain the os_pkg_info_list output")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform",
			"STDERR doesn't match")
		assert.Empty(t,
			out.String(),
			"STDOUT should be empty")
		assert.Equal(t, 1, exitcode,
			"EXITCODE is not the expected one")
	}
}

func TestHostVulnerabilityCommandScanPkgManifest(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "scan-pkg-manifest", "--local")

	if runtime.GOOS == "linux" {
		expectedOutput := []string{
			// headers
			"CVE",
			"SEVERITY",
			"SCORE",
			"PACKAGE",
			"VERSION",
			"FIX VERSION",

			// summary headers
			"VULNERABILITIES",
			"SEVERITY",
			"COUNT",
			"FIXABLE",
		}
		t.Run("verifying table headers", func(t *testing.T) {
			for _, str := range expectedOutput {
				assert.Contains(t, out.String(), str,
					"STDOUT table does not contain the '"+str+"' output")
			}
		})
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform",
			"STDERR doesn't match")
		assert.Empty(t,
			out.String(),
			"STDOUT should be empty")
		assert.Equal(t, 1, exitcode,
			"EXITCODE is not the expected one")

	}
}

func TestHostScanPkgManifestFailOnSeverity(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "scan-pkg-manifest", "--local", "--fail_on_severity", "medium")

	if runtime.GOOS == "linux" {
		// CLI should terminate with exit code 1
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR ENFORCE POLICY: vulnerabilities found with threshold 'medium' (exit code: 9)",
			"STDERR does not match")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform", "STDERR doesn't match")
		assert.Empty(t, out.String(), "STDOUT should be empty")
		assert.Equal(t, 1, exitcode, "EXITCODE is not the expected one")

	}
}

// Given fail_on_severity is set, when the vuln threshold is met, then the exit code should be 9
func TestHostVulnerabilityFailOnSeverityThreshold(t *testing.T) {
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_severity", "high")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR ENFORCE POLICY: vulnerabilities found with threshold 'high' (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_fixable is set, when any fixable vulns are found then the exit code should be 9
func TestHostVulnerabilityFailOnFixable(t *testing.T) {
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_fixable")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR ENFORCE POLICY: fixable vulnerabilities found (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_severity and fail_on_fixable are set, when the vuln threshold is met and result if fixable, then the exit code should be 9
func TestHostVulnerabilityFailOnFixableWithSeverity(t *testing.T) {
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_severity", "high", "--fail_on_fixable")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR ENFORCE POLICY: fixable vulnerabilities found with threshold 'high' (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_fixable is set and json output flag, when any fixable vulns are found then the exit code should be 9
func TestHostVulnerabilityFailOnFixableWithJson(t *testing.T) {
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_fixable", "--json")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR ENFORCE POLICY: fixable vulnerabilities found (exit code: 9)",
		"STDERR does not match")
}

func TestHostVulnerabilityListCvesFilterSeverity(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves", "--severity", "high")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "cve(s) showing",
		"Filtered assessment output should contain filtered result ")
}

func TestHostVulnerabilityAssessmentFilterSeverity(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--severity", "high")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "cve(s) showing",
		"Filtered assessment output should contain filtered result ")
}

func TestHostVulnerabilityListCvesFilterSeverityWithPackages(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves", "--severity", "high", "--packages")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "package(s) showing",
		"Filtered assessment output should contain filtered result ")
}
