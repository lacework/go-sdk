//go:build vulnerability

// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/lacework/go-sdk/api"
)

// persistent host "ip-10-0-1-170.us-west-2.compute.internal"
// NOTE: host will need to be updated "circle-ci-test-node" when RAIN-13990 is resolved
// managed by TF: github.com/lacework-dev/tech-ally-ci-environment
var (
	machineID = "30"
	hostname  = "circle-ci-test-node"
)

// Configure the correct machine id for vuln host tests
func init() {
	lw, err := laceworkIntegrationTestClient()
	if err == nil {
		// Check if the default machineID(30) exists
		if !machineIDExists(lw) {
			setHostVulnTestMachineID(lw)
		}
	}
}

func TestHostVulnerabilityCommandListCves(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves")
	expectedHeaders := []string{
		"CVE",
		"SEVERITY",
		"SCORE",
		"PACKAGE",
		"CURRENT VERSION",
		"FIX VERSION",
		"OS VERSION",
		"HOSTS",
		"PKG STATUS",
		"VULN STATUS",
	}
	t.Run("verify table headers", func(t *testing.T) {
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")

	assert.Contains(t, out.String(),
		"Try adding '--active' to only show vulnerabilities of packages actively running.",
		"STDOUT breadcrumbs changed, please update")
}

func TestHostVulnerabilityCommandsEndToEnd(t *testing.T) {
	var (
		out          bytes.Buffer
		err          bytes.Buffer
		exitcode     int
		hostVulnCVEs []api.HostVulnCVE
	)
	t.Run("list-cves", func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "host", "list-cves", "--json")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	})

	t.Run("inspecting json output", func(t *testing.T) {
		errJson := json.Unmarshal(out.Bytes(), &hostVulnCVEs)
		assert.Nil(t, errJson)
		assert.NotEmpty(t, hostVulnCVEs, "check JSON list-cves response")
	})

	cveID := hostVulnCVEs[0].ID
	t.Run(fmt.Sprintf("list-hosts for CVE '%s'", cveID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "host", "list-hosts", cveID)
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")

		expectedHeaders := []string{
			"MACHINE ID",
			"HOSTNAME",
			"EXTERNAL IP",
			"INTERNAL IP",
			"OS/ARCH",
			"PROVIDER",
			"INSTANCE ID",
			"VULNERABILITIES",
			"STATUS",
		}
		for _, header := range expectedHeaders {
			assert.Contains(t, out.String(), header,
				"STDOUT table headers changed, please check")
		}
	})

	// Test unmarshall Epoch time for last_evaluation_time
	t.Run(fmt.Sprintf("epoch time unmarshall list-hosts '%s'", cveID), func(t *testing.T) {
		out, err, exitcode = LaceworkCLIWithTOMLConfig(
			"vulnerability", "host", "list-hosts", cveID, "--json")
		assert.Empty(t, err.String(), "STDERR should be empty")
		assert.Contains(t, out.String(), "last_evaluation_time",
			"Json output does not contain last_evaluation_time")

		assert.True(t, validRFC3339("last_evaluation_time", out.String()), "last_evaluation_time is not valid")
	})
}

func TestHostVulnerabilityCommandShowAssessment(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "show-assessment", machineID)
	expectedOutput := []string{
		// headers
		"HOST DETAILS",
		"VULNERABILITIES",
		"SEVERITY",
		"COUNT",
		"FIXABLE",

		// fields
		"Machine ID   " + machineID,
		// @afiune this test is very lacky, it fails some times
		// https://github.com/lacework/go-sdk/issues/261
		"Hostname     " + hostname,
		"Os           linux",
		"Arch         amd64",
		"External IP",
		"Internal IP",
		"Namespace",
		"Provider",
		"Instance ID",
		"AMI",

		// severities
		"Critical",
		"High",
		"Medium",
		"Low",
		"Info",
	}
	t.Run("verifying table headers", func(t *testing.T) {
		for _, str := range expectedOutput {
			assert.Contains(t, out.String(), str,
				"STDOUT table does not contain the '"+str+"' output")
		}
		assert.Contains(t, out.String(), "Try adding '--details' to increase details shown about the vulnerability assessment.",
			"STDOUT breadcrumbs changed, please update")
	})
	assert.Empty(t,
		err.String(),
		"STDERR should be empty")
	assert.Equal(t, 0, exitcode,
		"EXITCODE is not the expected one")
}

func TestHostVulnerabilityCommandGeneratePkgManifest(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "generate-pkg-manifest")

	if runtime.GOOS == "linux" {
		assert.Contains(t, out.String(), "os_pkg_info_list",
			"STDOUT does not contain the os_pkg_info_list output")
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform",
			"STDERR doesn't match")
		assert.Empty(t,
			out.String(),
			"STDOUT should be empty")
		assert.Equal(t, 1, exitcode,
			"EXITCODE is not the expected one")
	}
}

func TestHostVulnerabilityCommandScanPkgManifest(t *testing.T) {
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "scan-pkg-manifest", "--local")

	if runtime.GOOS == "linux" {
		expectedOutput := []string{
			// headers
			"CVE",
			"SEVERITY",
			"SCORE",
			"PACKAGE",
			"VERSION",
			"FIX VERSION",

			// summary headers
			"VULNERABILITIES",
			"SEVERITY",
			"COUNT",
			"FIXABLE",
		}
		t.Run("verifying table headers", func(t *testing.T) {
			for _, str := range expectedOutput {
				assert.Contains(t, out.String(), str,
					"STDOUT table does not contain the '"+str+"' output")
			}
		})
		assert.Empty(t,
			err.String(),
			"STDERR should be empty")
		assert.Equal(t, 0, exitcode,
			"EXITCODE is not the expected one")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform",
			"STDERR doesn't match")
		assert.Empty(t,
			out.String(),
			"STDOUT should be empty")
		assert.Equal(t, 1, exitcode,
			"EXITCODE is not the expected one")

	}
}

func TestHostScanPkgManifestFailOnSeverity(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig(
		"vulnerability", "host", "scan-pkg-manifest", "--local", "--fail_on_severity", "medium")

	if runtime.GOOS == "linux" {
		// CLI should terminate with exit code 1
		assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
		assert.Contains(t, err.String(),
			"ERROR (FAIL-ON): vulnerabilities found with threshold 'medium' (exit code: 9)",
			"STDERR does not match")
	} else {
		assert.Contains(t, err.String(), "unable to generate package manifest: unsupported platform", "STDERR doesn't match")
		assert.Empty(t, out.String(), "STDOUT should be empty")
		assert.Equal(t, 1, exitcode, "EXITCODE is not the expected one")

	}
}

// Given fail_on_severity is set, when the vuln threshold is met, then the exit code should be 9
func TestHostVulnerabilityFailOnSeverityThreshold(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_severity", "high")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): vulnerabilities found with threshold 'high' (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_fixable is set, when any fixable vulns are found then the exit code should be 9
func TestHostVulnerabilityFailOnFixable(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_fixable")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): fixable vulnerabilities found (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_severity and fail_on_fixable are set, when the vuln threshold is met and result if fixable, then the exit code should be 9
func TestHostVulnerabilityFailOnFixableWithSeverity(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_severity", "high", "--fail_on_fixable")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): fixable vulnerabilities found with threshold 'high' (exit code: 9)",
		"STDERR does not match")
}

// Given fail_on_fixable is set and json output flag, when any fixable vulns are found then the exit code should be 9
func TestHostVulnerabilityFailOnFixableWithJson(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	_, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--fail_on_fixable", "--json")

	// CLI should terminate with exit code 9
	assert.Equal(t, 9, exitcode, "EXITCODE is not the expected one")
	assert.Contains(t, err.String(),
		"ERROR (FAIL-ON): fixable vulnerabilities found (exit code: 9)",
		"STDERR does not match")
}

func TestHostVulnerabilityListCvesFilterSeverity(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves", "--severity", "high")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "cve(s) showing",
		"Filtered assessment output should contain filtered result ")
}

func TestHostVulnerabilityAssessmentFilterSeverity(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "show-assessment", machineID, "--severity", "high")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "cve(s) showing",
		"Filtered assessment output should contain filtered result ")
}

func TestHostVulnerabilityListCvesFilterSeverityWithPackages(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves", "--severity", "high", "--packages")

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")

	showAssessmentOutput := out.String()
	assert.Contains(t, showAssessmentOutput, "package(s) showing",
		"Filtered assessment output should contain filtered result ")
}

func TestHostVulnerabilityListCvesFilterSeverityWithJson(t *testing.T) {
	if os.Getenv("CI_SKIP_HOST_VULN") != "" {
		t.Skip(fmt.Sprintf("skipping %s", t.Name()))
	}
	out, err, exitcode := LaceworkCLIWithTOMLConfig("vulnerability", "host", "list-cves", "--severity", "high", "--json")
	validSeverity := "\"severity\": \"High\""
	invalidSeverities := []string{"\"severity\": \"Medium\"", "\"severity\": \"Low\"", "\"severity\": \"Info\""}

	assert.Empty(t, err.String(), "STDERR should be empty")
	assert.Equal(t, 0, exitcode, "EXITCODE is not the expected one")
	// When high severity filter is set, other severities should not be returned in json result
	assert.NotContains(t, out.String(), invalidSeverities,
		"Json output does not adhere to severity filter: contains invalid severities")
	assert.Contains(t, out.String(), validSeverity,
		"Json output does not adhere to severity filter: does not contain valid severities")
}

func validRFC3339(field string, jsonString string) bool {
	jsonout := strings.Split(jsonString, fmt.Sprintf("%s\": ", field))[1]
	datetime := strings.Trim(strings.Split(jsonout, ",")[0], `"`)

	res, err := time.Parse(time.RFC3339, datetime)
	errorTime, _ := time.Parse(time.RFC3339, "1970-01-01T00:00:00Z")

	if nil != err || res.Equal(errorTime) {
		return false
	}
	return true
}

func machineIDExists(lw *api.Client) bool {
	resp, err := lw.Vulnerabilities.Host.GetHostAssessment(machineID)
	if err != nil {
		return false
	}
	return resp.Ok
}

func setHostVulnTestMachineID(lw *api.Client) {
	var cveID string
	cveResp, err := lw.Vulnerabilities.Host.ListCves()
	if err != nil {
		log.Fatalf("Unable to list cves %s\n", err)
	}

	if len(cveResp.CVEs) > 0 {
		for _, cve := range cveResp.CVEs {
			// get a host with 'critical' or 'high' vulnerabilities
			if cve.Summary.Severity.Critical != nil &&
				cve.Summary.Severity.Critical.Vulnerabilities > 0 {
				cveID = cve.ID
				break
			}
			if cve.Summary.Severity.High != nil &&
				cve.Summary.Severity.High.Vulnerabilities > 0 {
				cveID = cve.ID
				break
			}
		}
	} else {
		log.Fatal("No Host CVE's found")
	}

	hostResp, err := lw.Vulnerabilities.Host.ListHostsWithCVE(cveID)
	if err != nil {
		log.Fatalf("Unable to get host for cveID %s %s\n", cveID, err)
	}

	if len(hostResp.Hosts) == 0 {
		os.Setenv("CI_SKIP_HOST_VULN", "true")
	} else {
		found := false
		for _, host := range hostResp.Hosts {
			if host.Details.MachineStatus == "Online" {
				machineID = host.Details.MachineID
				hostname = host.Details.Hostname
				found = true
				break
			}
		}
		if !found {
			os.Setenv("CI_SKIP_HOST_VULN", "true")
		}
	}
}
