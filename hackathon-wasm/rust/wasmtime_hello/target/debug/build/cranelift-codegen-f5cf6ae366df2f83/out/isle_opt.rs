// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/algebraic.isle
// - src/opts/cprop.isle
// - /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v15,
                args: ref v16,
            } => {
                match v15 {
                    &Opcode::Iadd => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v65,
                                    args: ref v66,
                                } => {
                                    match v65 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v2.0 == v78.0 {
                                                                                let v320 = constructor_iadd(ctx, v2.0, v67.1, v17.1);
                                                                                let v321 = constructor_iadd(ctx, v2.0, v67.0, v320);
                                                                                // Rule at src/opts/cprop.isle line 122.
                                                                                returns.push(v321);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v2.0 == v78.0 {
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v83 = C::u64_from_imm64(ctx, v82);
                                                                                let v333 = C::u64_sub(ctx, v26, v83);
                                                                                let v334 = C::imm64_masked(ctx, v2.0, v333);
                                                                                let v335 = constructor_iconst(ctx, v2.0, v334);
                                                                                let v337 = constructor_iadd(ctx, v2.0, v67.0, v335);
                                                                                // Rule at src/opts/cprop.isle line 144.
                                                                                returns.push(v337);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v113 =
                                                                    C::inst_data_etor(ctx, v67.0);
                                                                let mut v113 = v113;
                                                                while let Some(v114) =
                                                                    v113.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v326,
                                                                        imm: v327,
                                                                    } = &v114.1 {
                                                                        if let &Opcode::Iconst = v326 {
                                                                            if v2.0 == v114.0 {
                                                                                let v328 = C::u64_from_imm64(ctx, v327);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v338 = C::u64_add(ctx, v328, v26);
                                                                                let v339 = C::imm64_masked(ctx, v2.0, v338);
                                                                                let v340 = constructor_iconst(ctx, v2.0, v339);
                                                                                let v341 = constructor_isub(ctx, v2.0, v340, v67.1);
                                                                                // Rule at src/opts/cprop.isle line 148.
                                                                                returns.push(v341);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 20.
                                                returns.push(v35);
                                            }
                                            let v311 = constructor_iadd(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 91.
                                            returns.push(v311);
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v29.0 == v38 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v247 =
                                                                    C::u64_add(ctx, v34, v26);
                                                                let v248 =
                                                                    C::imm64_masked(ctx, v38, v247);
                                                                let v249 = constructor_iconst(
                                                                    ctx, v38, v248,
                                                                );
                                                                let v250 = C::subsume(ctx, v249);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v250);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 270.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 16.
                                            returns.push(v27);
                                        }
                                    }
                                    let v133 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 272.
                                    returns.push(v133);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v65,
                                    args: ref v66,
                                } => {
                                    match v65 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v2.0 == v78.0 {
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v83 = C::u64_from_imm64(ctx, v82);
                                                                                let v333 = C::u64_sub(ctx, v26, v83);
                                                                                let v334 = C::imm64_masked(ctx, v2.0, v333);
                                                                                let v335 = constructor_iconst(ctx, v2.0, v334);
                                                                                let v336 = constructor_isub(ctx, v2.0, v67.0, v335);
                                                                                // Rule at src/opts/cprop.isle line 140.
                                                                                returns.push(v336);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v2.0 == v78.0 {
                                                                                let v83 = C::u64_from_imm64(ctx, v82);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v322 = C::u64_add(ctx, v83, v26);
                                                                                let v323 = C::imm64_masked(ctx, v2.0, v322);
                                                                                let v324 = constructor_iconst(ctx, v2.0, v323);
                                                                                let v325 = constructor_isub(ctx, v2.0, v67.0, v324);
                                                                                // Rule at src/opts/cprop.isle line 132.
                                                                                returns.push(v325);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v113 =
                                                                    C::inst_data_etor(ctx, v67.0);
                                                                let mut v113 = v113;
                                                                while let Some(v114) =
                                                                    v113.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v326,
                                                                        imm: v327,
                                                                    } = &v114.1 {
                                                                        if let &Opcode::Iconst = v326 {
                                                                            if v2.0 == v114.0 {
                                                                                let v328 = C::u64_from_imm64(ctx, v327);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v329 = C::u64_sub(ctx, v328, v26);
                                                                                let v330 = C::imm64_masked(ctx, v2.0, v329);
                                                                                let v331 = constructor_iconst(ctx, v2.0, v330);
                                                                                let v332 = constructor_isub(ctx, v2.0, v331, v67.1);
                                                                                // Rule at src/opts/cprop.isle line 136.
                                                                                returns.push(v332);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v36 = constructor_ineg(ctx, v2.0, v17.1);
                                                // Rule at src/opts/algebraic.isle line 30.
                                                returns.push(v36);
                                            }
                                            let v312 = constructor_isub(ctx, v2.0, v17.1, v17.0);
                                            let v313 = constructor_ineg(ctx, v2.0, v312);
                                            // Rule at src/opts/cprop.isle line 96.
                                            returns.push(v313);
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v29.0 == v38 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v251 =
                                                                    C::u64_sub(ctx, v34, v26);
                                                                let v252 =
                                                                    C::imm64_masked(ctx, v38, v251);
                                                                let v253 = constructor_iconst(
                                                                    ctx, v38, v252,
                                                                );
                                                                let v254 = C::subsume(ctx, v253);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v254);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 274.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 25.
                                            returns.push(v27);
                                        }
                                    }
                                    let v133 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 276.
                                    returns.push(v133);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v65,
                                    args: ref v66,
                                } => {
                                    if let &Opcode::Imul = v65 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        if v2.0 == v21.0 {
                                                            let v67 =
                                                                C::unpack_value_array_2(ctx, v66);
                                                            let v77 = C::inst_data_etor(ctx, v67.1);
                                                            let mut v77 = v77;
                                                            while let Some(v78) = v77.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v81,
                                                                    imm: v82,
                                                                } = &v78.1 {
                                                                    if let &Opcode::Iconst = v81 {
                                                                        if v2.0 == v78.0 {
                                                                            let v342 = constructor_imul(ctx, v2.0, v67.1, v17.1);
                                                                            let v343 = constructor_imul(ctx, v2.0, v67.0, v342);
                                                                            // Rule at src/opts/cprop.isle line 153.
                                                                            returns.push(v343);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            match v34 {
                                                0x0 => {
                                                    let v27 = C::subsume(ctx, v17.0);
                                                    // Rule at src/opts/algebraic.isle line 50.
                                                    returns.push(v27);
                                                }
                                                0x1 => {
                                                    let v35 = C::subsume(ctx, v17.1);
                                                    // Rule at src/opts/algebraic.isle line 40.
                                                    returns.push(v35);
                                                }
                                                _ => {}
                                            }
                                            let v314 = constructor_imul(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v314);
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v29.0 == v38 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v255 =
                                                                    C::u64_mul(ctx, v34, v26);
                                                                let v256 =
                                                                    C::imm64_masked(ctx, v38, v255);
                                                                let v257 = constructor_iconst(
                                                                    ctx, v38, v256,
                                                                );
                                                                let v258 = C::subsume(ctx, v257);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v258);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v92 = C::simm32(ctx, v33);
                                        if let Some(v93) = v92 {
                                            if v93 == 0x2 {
                                                let v94 = constructor_iadd(ctx, v2.0, v17.1, v17.1);
                                                // Rule at src/opts/algebraic.isle line 178.
                                                returns.push(v94);
                                            }
                                        }
                                        let v100 = C::imm64_power_of_two(ctx, v33);
                                        if let Some(v101) = v100 {
                                            let v102 = C::imm64(ctx, v101);
                                            let v103 = constructor_iconst(ctx, v2.0, v102);
                                            let v104 = constructor_ishl(ctx, v2.0, v17.1, v103);
                                            // Rule at src/opts/algebraic.isle line 187.
                                            returns.push(v104);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    match v26 {
                                        0x0 => {
                                            if v2.0 == v21.0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 46.
                                                returns.push(v35);
                                            }
                                        }
                                        0x1 => {
                                            if v2.0 == v21.0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 36.
                                                returns.push(v27);
                                            }
                                        }
                                        _ => {}
                                    }
                                    let v89 = C::simm32(ctx, v25);
                                    if let Some(v90) = v89 {
                                        if v90 == 0x2 {
                                            let v91 = constructor_iadd(ctx, v2.0, v17.0, v17.0);
                                            // Rule at src/opts/algebraic.isle line 176.
                                            returns.push(v91);
                                        }
                                    }
                                    let v95 = C::imm64_power_of_two(ctx, v25);
                                    if let Some(v96) = v95 {
                                        let v97 = C::imm64(ctx, v96);
                                        let v98 = constructor_iconst(ctx, v2.0, v97);
                                        let v99 = constructor_ishl(ctx, v2.0, v17.0, v98);
                                        // Rule at src/opts/algebraic.isle line 185.
                                        returns.push(v99);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x1 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 60.
                                            returns.push(v27);
                                        }
                                    }
                                    let v37 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v38) = v37 {
                                        if v21.0 == v38 {
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Iconst = v32 {
                                                        let v34 = C::u64_from_imm64(ctx, v33);
                                                        let v264 = C::u64_udiv(ctx, v34, v26);
                                                        if let Some(v265) = v264 {
                                                            if v21.0 == v29.0 {
                                                                let v266 =
                                                                    C::imm64_masked(ctx, v38, v265);
                                                                let v267 = constructor_iconst(
                                                                    ctx, v38, v266,
                                                                );
                                                                let v268 = C::subsume(ctx, v267);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v268);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x1 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 56.
                                            returns.push(v27);
                                        }
                                    }
                                    let v37 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v38) = v37 {
                                        if v21.0 == v38 {
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Iconst = v32 {
                                                        let v34 = C::u64_from_imm64(ctx, v33);
                                                        let v259 = C::u64_sdiv(ctx, v34, v26);
                                                        if let Some(v260) = v259 {
                                                            if v21.0 == v29.0 {
                                                                let v261 =
                                                                    C::imm64_masked(ctx, v38, v260);
                                                                let v262 = constructor_iconst(
                                                                    ctx, v38, v261,
                                                                );
                                                                let v263 = C::subsume(ctx, v262);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v263);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v65,
                                    args: ref v66,
                                } => {
                                    if let &Opcode::Band = v65 {
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        if v2.0 == v21.0 {
                                                            let v67 =
                                                                C::unpack_value_array_2(ctx, v66);
                                                            let v77 = C::inst_data_etor(ctx, v67.1);
                                                            let mut v77 = v77;
                                                            while let Some(v78) = v77.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v81,
                                                                    imm: v82,
                                                                } = &v78.1 {
                                                                    if let &Opcode::Iconst = v81 {
                                                                        if v2.0 == v78.0 {
                                                                            let v346 = constructor_band(ctx, v2.0, v67.1, v17.1);
                                                                            let v347 = constructor_band(ctx, v2.0, v67.0, v346);
                                                                            // Rule at src/opts/cprop.isle line 159.
                                                                            returns.push(v347);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v202,
                                    args: ref v203,
                                    cond: ref v204,
                                } => {
                                    if let &Opcode::Icmp = v202 {
                                        let v200 = C::ty_int(ctx, v2.0);
                                        if let Some(v201) = v200 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        if v26 == 0x1 {
                                                            // Rule at src/opts/algebraic.isle line 363.
                                                            returns.push(v17.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v51,
                                    arg: v52,
                                } => {
                                    match v51 {
                                        &Opcode::Bnot => {
                                            let v37 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v38) = v37 {
                                                let v39 = C::ty_int(ctx, v38);
                                                if let Some(v40) = v39 {
                                                    if v17.1 == v52 {
                                                        if v29.0 == v40 {
                                                            let v42 = C::imm64(ctx, 0x0);
                                                            let v43 =
                                                                constructor_iconst(ctx, v40, v42);
                                                            let v44 = C::subsume(ctx, v43);
                                                            // Rule at src/opts/algebraic.isle line 134.
                                                            returns.push(v44);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        if v26 == 0x1 {
                                                            let v200 = C::ty_int(ctx, v2.0);
                                                            if let Some(v201) = v200 {
                                                                let v208 =
                                                                    C::inst_data_etor(ctx, v52);
                                                                let mut v208 = v208;
                                                                while let Some(v209) =
                                                                    v208.next(ctx)
                                                                {
                                                                    if let &InstructionData::IntCompare {
                                                                        opcode: ref v212,
                                                                        args: ref v213,
                                                                        cond: ref v214,
                                                                    } = &v209.1 {
                                                                        if let &Opcode::Icmp = v212 {
                                                                            // Rule at src/opts/algebraic.isle line 368.
                                                                            returns.push(v17.0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        let v127 = C::value_type(ctx, v52);
                                                        let v128 = C::ty_mask(ctx, v127);
                                                        let v129 = C::u64_and(ctx, v26, v128);
                                                        let v130 = C::u64_eq(ctx, v128, v129);
                                                        if v130 == true {
                                                            // Rule at src/opts/algebraic.isle line 256.
                                                            returns.push(v17.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v24,
                                                    imm: v25,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Iconst = v24 {
                                                        let v26 = C::u64_from_imm64(ctx, v25);
                                                        let v127 = C::value_type(ctx, v52);
                                                        let v128 = C::ty_mask(ctx, v127);
                                                        let v131 = C::u64_eq(ctx, v26, v128);
                                                        if v131 == true {
                                                            let v132 =
                                                                constructor_uextend(ctx, v2.0, v52);
                                                            // Rule at src/opts/algebraic.isle line 262.
                                                            returns.push(v132);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 132.
                                                returns.push(v27);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v33);
                                            if v54 == -0x1 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 126.
                                                returns.push(v35);
                                            }
                                            let v316 = constructor_band(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v316);
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v29.0 == v38 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v273 =
                                                                    C::u64_and(ctx, v34, v26);
                                                                let v274 =
                                                                    C::imm64_masked(ctx, v38, v273);
                                                                let v275 = constructor_iconst(
                                                                    ctx, v38, v274,
                                                                );
                                                                let v276 = C::subsume(ctx, v275);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v276);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 278.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Bnot = v45 {
                                        if v17.0 == v46 {
                                            let v37 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v38) = v37 {
                                                let v39 = C::ty_int(ctx, v38);
                                                if let Some(v40) = v39 {
                                                    if v21.0 == v40 {
                                                        let v42 = C::imm64(ctx, 0x0);
                                                        let v43 = constructor_iconst(ctx, v40, v42);
                                                        let v44 = C::subsume(ctx, v43);
                                                        // Rule at src/opts/algebraic.isle line 133.
                                                        returns.push(v44);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        if v2.0 == v21.0 {
                                            let v26 = C::u64_from_imm64(ctx, v25);
                                            if v26 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 131.
                                                returns.push(v35);
                                            }
                                            let v53 = C::i64_sextend_imm64(ctx, v2.0, v25);
                                            if v53 == -0x1 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 123.
                                                returns.push(v27);
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 280.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v27 = C::subsume(ctx, v17.0);
                            // Rule at src/opts/algebraic.isle line 122.
                            returns.push(v27);
                        }
                    }
                    &Opcode::Bor => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Binary {
                                    opcode: ref v65,
                                    args: ref v66,
                                } => {
                                    match v65 {
                                        &Opcode::Band => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    match &v21.1 {
                                                        &InstructionData::Unary {
                                                            opcode: ref v45,
                                                            arg: v46,
                                                        } => {
                                                            if let &Opcode::Bnot = v45 {
                                                                if v2.0 == v21.0 {
                                                                    let v67 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v66,
                                                                        );
                                                                    if v46 == v67.1 {
                                                                        let v70 = constructor_bor(
                                                                            ctx, v2.0, v67.0, v17.1,
                                                                        );
                                                                        // Rule at src/opts/algebraic.isle line 148.
                                                                        returns.push(v70);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v24,
                                                            imm: v25,
                                                        } => {
                                                            if let &Opcode::Iconst = v24 {
                                                                if v2.0 == v21.0 {
                                                                    let v67 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v66,
                                                                        );
                                                                    let v77 = C::inst_data_etor(
                                                                        ctx, v67.1,
                                                                    );
                                                                    let mut v77 = v77;
                                                                    while let Some(v78) =
                                                                        v77.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v81,
                                                                            imm: v82,
                                                                        } = &v78.1 {
                                                                            if let &Opcode::Iconst = v81 {
                                                                                let v84 = C::ty_mask(ctx, v2.0);
                                                                                let v26 = C::u64_from_imm64(ctx, v25);
                                                                                let v85 = C::u64_and(ctx, v84, v26);
                                                                                let v83 = C::u64_from_imm64(ctx, v82);
                                                                                let v86 = C::u64_not(ctx, v83);
                                                                                let v87 = C::u64_and(ctx, v84, v86);
                                                                                let v88 = C::u64_eq(ctx, v85, v87);
                                                                                if v88 == true {
                                                                                    if v2.0 == v78.0 {
                                                                                        let v70 = constructor_bor(ctx, v2.0, v67.0, v17.1);
                                                                                        // Rule at src/opts/algebraic.isle line 168.
                                                                                        returns.push(v70);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v29.0 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v2.0 == v21.0 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v2.0 == v78.0 {
                                                                                let v344 = constructor_bor(ctx, v2.0, v67.1, v17.1);
                                                                                let v345 = constructor_bor(ctx, v2.0, v67.0, v344);
                                                                                // Rule at src/opts/cprop.isle line 156.
                                                                                returns.push(v345);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v51,
                                    arg: v52,
                                } => {
                                    if let &Opcode::Bnot = v51 {
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            let v39 = C::ty_int(ctx, v38);
                                            if let Some(v40) = v39 {
                                                if v17.1 == v52 {
                                                    if v29.0 == v40 {
                                                        let v47 = C::ty_mask(ctx, v40);
                                                        let v48 = C::imm64(ctx, v47);
                                                        let v49 = constructor_iconst(ctx, v40, v48);
                                                        let v50 = C::subsume(ctx, v49);
                                                        // Rule at src/opts/algebraic.isle line 119.
                                                        returns.push(v50);
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v29.0 {
                                            let v20 = C::inst_data_etor(ctx, v17.1);
                                            let mut v20 = v20;
                                            while let Some(v21) = v20.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v71,
                                                    args: ref v72,
                                                } = &v21.1
                                                {
                                                    if let &Opcode::Band = v71 {
                                                        if v2.0 == v21.0 {
                                                            let v73 =
                                                                C::unpack_value_array_2(ctx, v72);
                                                            if v52 == v73.1 {
                                                                let v76 = constructor_bor(
                                                                    ctx, v2.0, v73.0, v17.0,
                                                                );
                                                                // Rule at src/opts/algebraic.isle line 157.
                                                                returns.push(v76);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 92.
                                                returns.push(v35);
                                            }
                                            let v315 = constructor_bor(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 103.
                                            returns.push(v315);
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v29.0 == v38 {
                                                let v20 = C::inst_data_etor(ctx, v17.1);
                                                let mut v20 = v20;
                                                while let Some(v21) = v20.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v24,
                                                        imm: v25,
                                                    } = &v21.1
                                                    {
                                                        if let &Opcode::Iconst = v24 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v269 = C::u64_or(ctx, v34, v26);
                                                                let v270 =
                                                                    C::imm64_masked(ctx, v38, v269);
                                                                let v271 = constructor_iconst(
                                                                    ctx, v38, v270,
                                                                );
                                                                let v272 = C::subsume(ctx, v271);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v272);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 282.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Bnot = v45 {
                                        if v17.0 == v46 {
                                            let v37 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v38) = v37 {
                                                let v39 = C::ty_int(ctx, v38);
                                                if let Some(v40) = v39 {
                                                    if v21.0 == v40 {
                                                        let v47 = C::ty_mask(ctx, v40);
                                                        let v48 = C::imm64(ctx, v47);
                                                        let v49 = constructor_iconst(ctx, v40, v48);
                                                        let v50 = C::subsume(ctx, v49);
                                                        // Rule at src/opts/algebraic.isle line 118.
                                                        returns.push(v50);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        let v26 = C::u64_from_imm64(ctx, v25);
                                        if v26 == 0x0 {
                                            if v2.0 == v21.0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 88.
                                                returns.push(v27);
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 284.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v27 = C::subsume(ctx, v17.0);
                            // Rule at src/opts/algebraic.isle line 96.
                            returns.push(v27);
                        }
                    }
                    &Opcode::Bxor => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            match &v21.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Bnot = v45 {
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            let v39 = C::ty_int(ctx, v38);
                                            if let Some(v40) = v39 {
                                                if v17.0 == v46 {
                                                    if v21.0 == v40 {
                                                        let v47 = C::ty_mask(ctx, v40);
                                                        let v48 = C::imm64(ctx, v47);
                                                        let v49 = constructor_iconst(ctx, v40, v48);
                                                        let v50 = C::subsume(ctx, v49);
                                                        // Rule at src/opts/algebraic.isle line 116.
                                                        returns.push(v50);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v24,
                                    imm: v25,
                                } => {
                                    if let &Opcode::Iconst = v24 {
                                        if v2.0 == v21.0 {
                                            let v26 = C::u64_from_imm64(ctx, v25);
                                            if v26 == 0x0 {
                                                let v27 = C::subsume(ctx, v17.0);
                                                // Rule at src/opts/algebraic.isle line 100.
                                                returns.push(v27);
                                            }
                                            let v53 = C::i64_sextend_imm64(ctx, v2.0, v25);
                                            if v53 == -0x1 {
                                                let v199 = constructor_bnot(ctx, v2.0, v17.0);
                                                // Rule at src/opts/algebraic.isle line 355.
                                                returns.push(v199);
                                            }
                                            let v28 = C::inst_data_etor(ctx, v17.0);
                                            let mut v28 = v28;
                                            while let Some(v29) = v28.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v65,
                                                    args: ref v66,
                                                } = &v29.1
                                                {
                                                    if let &Opcode::Bxor = v65 {
                                                        if v2.0 == v29.0 {
                                                            let v67 =
                                                                C::unpack_value_array_2(ctx, v66);
                                                            let v77 = C::inst_data_etor(ctx, v67.1);
                                                            let mut v77 = v77;
                                                            while let Some(v78) = v77.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v81,
                                                                    imm: v82,
                                                                } = &v78.1 {
                                                                    if let &Opcode::Iconst = v81 {
                                                                        if v2.0 == v78.0 {
                                                                            let v348 = constructor_bxor(ctx, v2.0, v67.1, v17.1);
                                                                            let v349 = constructor_bxor(ctx, v2.0, v67.0, v348);
                                                                            // Rule at src/opts/cprop.isle line 162.
                                                                            returns.push(v349);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v21.0 == v38 {
                                                let v28 = C::inst_data_etor(ctx, v17.0);
                                                let mut v28 = v28;
                                                while let Some(v29) = v28.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v32,
                                                        imm: v33,
                                                    } = &v29.1
                                                    {
                                                        if let &Opcode::Iconst = v32 {
                                                            if v21.0 == v29.0 {
                                                                let v34 =
                                                                    C::u64_from_imm64(ctx, v33);
                                                                let v26 =
                                                                    C::u64_from_imm64(ctx, v25);
                                                                let v277 =
                                                                    C::u64_xor(ctx, v34, v26);
                                                                let v278 =
                                                                    C::imm64_masked(ctx, v38, v277);
                                                                let v279 = constructor_iconst(
                                                                    ctx, v38, v278,
                                                                );
                                                                let v280 = C::subsume(ctx, v279);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v280);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 288.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v28 = C::inst_data_etor(ctx, v17.0);
                        let mut v28 = v28;
                        while let Some(v29) = v28.next(ctx) {
                            match &v29.1 {
                                &InstructionData::Unary {
                                    opcode: ref v51,
                                    arg: v52,
                                } => {
                                    if let &Opcode::Bnot = v51 {
                                        if v17.1 == v52 {
                                            let v37 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v38) = v37 {
                                                let v39 = C::ty_int(ctx, v38);
                                                if let Some(v40) = v39 {
                                                    if v29.0 == v40 {
                                                        let v47 = C::ty_mask(ctx, v40);
                                                        let v48 = C::imm64(ctx, v47);
                                                        let v49 = constructor_iconst(ctx, v40, v48);
                                                        let v50 = C::subsume(ctx, v49);
                                                        // Rule at src/opts/algebraic.isle line 117.
                                                        returns.push(v50);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v32,
                                    imm: v33,
                                } => {
                                    if let &Opcode::Iconst = v32 {
                                        if v2.0 == v29.0 {
                                            let v34 = C::u64_from_imm64(ctx, v33);
                                            if v34 == 0x0 {
                                                let v35 = C::subsume(ctx, v17.1);
                                                // Rule at src/opts/algebraic.isle line 104.
                                                returns.push(v35);
                                            }
                                            let v317 = constructor_bxor(ctx, v2.0, v17.1, v17.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v317);
                                        }
                                        let v133 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 286.
                                        returns.push(v133);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v17.0 == v17.1 {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v42 = C::imm64(ctx, 0x0);
                                    let v43 = constructor_iconst(ctx, v40, v42);
                                    let v44 = C::subsume(ctx, v43);
                                    // Rule at src/opts/algebraic.isle line 110.
                                    returns.push(v44);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 82.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 78.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v37 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v38) = v37 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            match &v29.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v65,
                                                    args: ref v66,
                                                } => {
                                                    match v65 {
                                                        &Opcode::Ushr => {
                                                            if v29.0 == v38 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v25 == v82 {
                                                                                let v106 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v107 = C::imm64_shl(ctx, v38, v106, v82);
                                                                                let v108 = constructor_iconst(ctx, v38, v107);
                                                                                let v109 = constructor_band(ctx, v38, v67.0, v108);
                                                                                // Rule at src/opts/algebraic.isle line 196.
                                                                                returns.push(v109);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v29.0 == v38 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v25 == v82 {
                                                                                let v106 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v107 = C::imm64_shl(ctx, v38, v106, v82);
                                                                                let v108 = constructor_iconst(ctx, v38, v107);
                                                                                let v109 = constructor_band(ctx, v38, v67.0, v108);
                                                                                // Rule at src/opts/algebraic.isle line 201.
                                                                                returns.push(v109);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } => {
                                                    if let &Opcode::Iconst = v32 {
                                                        if v29.0 == v38 {
                                                            let v288 =
                                                                C::imm64_shl(ctx, v38, v33, v25);
                                                            let v289 =
                                                                constructor_iconst(ctx, v38, v288);
                                                            let v290 = C::subsume(ctx, v289);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v290);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 66.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v37 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v38) = v37 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            match &v29.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v65,
                                                    args: ref v66,
                                                } => {
                                                    if let &Opcode::Ishl = v65 {
                                                        let v39 = C::ty_int(ctx, v38);
                                                        if let Some(v40) = v39 {
                                                            if v29.0 == v40 {
                                                                let v67 = C::unpack_value_array_2(
                                                                    ctx, v66,
                                                                );
                                                                let v77 =
                                                                    C::inst_data_etor(ctx, v67.1);
                                                                let mut v77 = v77;
                                                                while let Some(v78) = v77.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v81,
                                                                        imm: v82,
                                                                    } = &v78.1 {
                                                                        if let &Opcode::Iconst = v81 {
                                                                            if v25 == v82 {
                                                                                let v47 = C::ty_mask(ctx, v40);
                                                                                let v48 = C::imm64(ctx, v47);
                                                                                let v110 = C::imm64_ushr(ctx, v40, v48, v82);
                                                                                let v111 = constructor_iconst(ctx, v40, v110);
                                                                                let v112 = constructor_band(ctx, v40, v67.0, v111);
                                                                                // Rule at src/opts/algebraic.isle line 211.
                                                                                returns.push(v112);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v32,
                                                    imm: v33,
                                                } => {
                                                    if let &Opcode::Iconst = v32 {
                                                        if v29.0 == v38 {
                                                            let v291 =
                                                                C::imm64_ushr(ctx, v38, v33, v25);
                                                            let v292 =
                                                                constructor_iconst(ctx, v38, v291);
                                                            let v293 = C::subsume(ctx, v292);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v293);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 70.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v24,
                                imm: v25,
                            } = &v21.1
                            {
                                if let &Opcode::Iconst = v24 {
                                    let v28 = C::inst_data_etor(ctx, v17.0);
                                    let mut v28 = v28;
                                    while let Some(v29) = v28.next(ctx) {
                                        match &v29.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v65,
                                                args: ref v66,
                                            } => {
                                                if let &Opcode::Ishl = v65 {
                                                    if v2.0 == v29.0 {
                                                        let v67 = C::unpack_value_array_2(ctx, v66);
                                                        let v77 = C::inst_data_etor(ctx, v67.1);
                                                        let mut v77 = v77;
                                                        while let Some(v78) = v77.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v81,
                                                                imm: v82,
                                                            } = &v78.1
                                                            {
                                                                if let &Opcode::Iconst = v81 {
                                                                    if v25 == v82 {
                                                                        let v113 =
                                                                            C::inst_data_etor(
                                                                                ctx, v67.0,
                                                                            );
                                                                        let mut v113 = v113;
                                                                        while let Some(v114) =
                                                                            v113.next(ctx)
                                                                        {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v117,
                                                                                arg: v118,
                                                                            } = &v114.1 {
                                                                                match v117 {
                                                                                    &Opcode::Uextend => {
                                                                                        if v2.0 == v114.0 {
                                                                                            let v83 = C::u64_from_imm64(ctx, v82);
                                                                                            let v120 = C::ty_bits_u64(ctx, v2.0);
                                                                                            let v119 = C::value_type(ctx, v118);
                                                                                            let v121 = C::ty_bits_u64(ctx, v119);
                                                                                            let v122 = C::u64_sub(ctx, v120, v121);
                                                                                            let v123 = C::u64_eq(ctx, v83, v122);
                                                                                            if v123 == true {
                                                                                                let v124 = constructor_sextend(ctx, v2.0, v118);
                                                                                                // Rule at src/opts/algebraic.isle line 221.
                                                                                                returns.push(v124);
                                                                                            }
                                                                                            let v125 = C::u64_lt(ctx, v83, v122);
                                                                                            if v125 == true {
                                                                                                // Rule at src/opts/algebraic.isle line 233.
                                                                                                returns.push(v67.0);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    &Opcode::Sextend => {
                                                                                        let v83 = C::u64_from_imm64(ctx, v82);
                                                                                        let v120 = C::ty_bits_u64(ctx, v2.0);
                                                                                        let v119 = C::value_type(ctx, v118);
                                                                                        let v121 = C::ty_bits_u64(ctx, v119);
                                                                                        let v122 = C::u64_sub(ctx, v120, v121);
                                                                                        let v126 = C::u64_le(ctx, v83, v122);
                                                                                        if v126 == true {
                                                                                            if v2.0 == v114.0 {
                                                                                                // Rule at src/opts/algebraic.isle line 244.
                                                                                                returns.push(v67.0);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    _ => {}
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v32,
                                                imm: v33,
                                            } => {
                                                if let &Opcode::Iconst = v32 {
                                                    let v37 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v38) = v37 {
                                                        if v29.0 == v38 {
                                                            let v294 =
                                                                C::imm64_sshr(ctx, v38, v33, v25);
                                                            let v295 =
                                                                constructor_iconst(ctx, v38, v294);
                                                            let v296 = C::subsume(ctx, v295);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v296);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v26 = C::u64_from_imm64(ctx, v25);
                                    if v26 == 0x0 {
                                        if v2.0 == v21.0 {
                                            let v27 = C::subsume(ctx, v17.0);
                                            // Rule at src/opts/algebraic.isle line 74.
                                            returns.push(v27);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fmul => {
                        let v17 = C::unpack_value_array_2(ctx, v16);
                        let v20 = C::inst_data_etor(ctx, v17.1);
                        let mut v20 = v20;
                        while let Some(v21) = v20.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v21.1
                            {
                                if let &Opcode::Fneg = v45 {
                                    if v2.0 == v21.0 {
                                        let v28 = C::inst_data_etor(ctx, v17.0);
                                        let mut v28 = v28;
                                        while let Some(v29) = v28.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v51,
                                                arg: v52,
                                            } = &v29.1
                                            {
                                                if let &Opcode::Fneg = v51 {
                                                    if v2.0 == v29.0 {
                                                        let v246 =
                                                            constructor_fmul(ctx, v2.0, v52, v46);
                                                        // Rule at src/opts/algebraic.isle line 538.
                                                        returns.push(v246);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v140,
                args: ref v141,
                cond: ref v142,
            } => {
                if let &Opcode::Icmp = v140 {
                    match v142 {
                        &IntCC::Equal => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v197 = C::imm64(ctx, 0x1);
                                        let v198 = constructor_iconst(ctx, v40, v197);
                                        // Rule at src/opts/algebraic.isle line 323.
                                        returns.push(v198);
                                    }
                                }
                            }
                            let v143 = C::unpack_value_array_2(ctx, v141);
                            let v146 = C::inst_data_etor(ctx, v143.0);
                            let mut v146 = v146;
                            while let Some(v147) = v146.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v150,
                                    arg: v151,
                                } = &v147.1
                                {
                                    if let &Opcode::Uextend = v150 {
                                        let v152 = C::inst_data_etor(ctx, v151);
                                        let mut v152 = v152;
                                        while let Some(v153) = v152.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v156,
                                                args: ref v157,
                                                cond: ref v158,
                                            } = &v153.1
                                            {
                                                if let &Opcode::Icmp = v156 {
                                                    if v2.0 == v153.0 {
                                                        let v162 = C::inst_data_etor(ctx, v143.1);
                                                        let mut v162 = v162;
                                                        while let Some(v163) = v162.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v166,
                                                                imm: v167,
                                                            } = &v163.1
                                                            {
                                                                if let &Opcode::Iconst = v166 {
                                                                    let v168 = C::u64_from_imm64(
                                                                        ctx, v167,
                                                                    );
                                                                    if v168 == 0x0 {
                                                                        let v170 =
                                                                            &C::intcc_inverse(
                                                                                ctx, v158,
                                                                            );
                                                                        let v159 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v157,
                                                                            );
                                                                        let v171 = constructor_icmp(
                                                                            ctx, v2.0, v170,
                                                                            v159.0, v159.1,
                                                                        );
                                                                        let v172 =
                                                                            C::subsume(ctx, v171);
                                                                        // Rule at src/opts/algebraic.isle line 306.
                                                                        returns.push(v172);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v42 = C::imm64(ctx, 0x0);
                                        let v43 = constructor_iconst(ctx, v40, v42);
                                        // Rule at src/opts/algebraic.isle line 326.
                                        returns.push(v43);
                                    }
                                }
                            }
                            let v143 = C::unpack_value_array_2(ctx, v141);
                            let v146 = C::inst_data_etor(ctx, v143.0);
                            let mut v146 = v146;
                            while let Some(v147) = v146.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v150,
                                    arg: v151,
                                } = &v147.1
                                {
                                    if let &Opcode::Uextend = v150 {
                                        let v152 = C::inst_data_etor(ctx, v151);
                                        let mut v152 = v152;
                                        while let Some(v153) = v152.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v156,
                                                args: ref v157,
                                                cond: ref v158,
                                            } = &v153.1
                                            {
                                                if let &Opcode::Icmp = v156 {
                                                    if v2.0 == v153.0 {
                                                        let v162 = C::inst_data_etor(ctx, v143.1);
                                                        let mut v162 = v162;
                                                        while let Some(v163) = v162.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v166,
                                                                imm: v167,
                                                            } = &v163.1
                                                            {
                                                                if let &Opcode::Iconst = v166 {
                                                                    let v168 = C::u64_from_imm64(
                                                                        ctx, v167,
                                                                    );
                                                                    if v168 == 0x0 {
                                                                        let v169 =
                                                                            C::subsume(ctx, v151);
                                                                        // Rule at src/opts/algebraic.isle line 300.
                                                                        returns.push(v169);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v42 = C::imm64(ctx, 0x0);
                                        let v43 = constructor_iconst(ctx, v40, v42);
                                        // Rule at src/opts/algebraic.isle line 335.
                                        returns.push(v43);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v197 = C::imm64(ctx, 0x1);
                                        let v198 = constructor_iconst(ctx, v40, v197);
                                        // Rule at src/opts/algebraic.isle line 338.
                                        returns.push(v198);
                                    }
                                }
                            }
                            let v200 = C::ty_int(ctx, v2.0);
                            if let Some(v201) = v200 {
                                let v143 = C::unpack_value_array_2(ctx, v141);
                                let v146 = C::inst_data_etor(ctx, v143.0);
                                let mut v146 = v146;
                                while let Some(v147) = v146.next(ctx) {
                                    if v147.0 == I64 {
                                        if let &InstructionData::Unary {
                                            opcode: ref v150,
                                            arg: v151,
                                        } = &v147.1
                                        {
                                            if let &Opcode::Uextend = v150 {
                                                let v218 = C::value_type(ctx, v151);
                                                if v218 == I32 {
                                                    let v162 = C::inst_data_etor(ctx, v143.1);
                                                    let mut v162 = v162;
                                                    while let Some(v163) = v162.next(ctx) {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref v166,
                                                            imm: v167,
                                                        } = &v163.1
                                                        {
                                                            if let &Opcode::Iconst = v166 {
                                                                let v168 =
                                                                    C::u64_from_imm64(ctx, v167);
                                                                if v168 == 0x0 {
                                                                    let v197 = C::imm64(ctx, 0x1);
                                                                    let v220 = constructor_iconst(
                                                                        ctx, v201, v197,
                                                                    );
                                                                    // Rule at src/opts/algebraic.isle line 396.
                                                                    returns.push(v220);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v42 = C::imm64(ctx, 0x0);
                                        let v43 = constructor_iconst(ctx, v40, v42);
                                        // Rule at src/opts/algebraic.isle line 347.
                                        returns.push(v43);
                                    }
                                }
                            }
                            let v200 = C::ty_int(ctx, v2.0);
                            if let Some(v201) = v200 {
                                let v143 = C::unpack_value_array_2(ctx, v141);
                                let v146 = C::inst_data_etor(ctx, v143.0);
                                let mut v146 = v146;
                                while let Some(v147) = v146.next(ctx) {
                                    if v147.0 == I64 {
                                        if let &InstructionData::Unary {
                                            opcode: ref v150,
                                            arg: v151,
                                        } = &v147.1
                                        {
                                            if let &Opcode::Uextend = v150 {
                                                let v218 = C::value_type(ctx, v151);
                                                if v218 == I32 {
                                                    let v162 = C::inst_data_etor(ctx, v143.1);
                                                    let mut v162 = v162;
                                                    while let Some(v163) = v162.next(ctx) {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref v166,
                                                            imm: v167,
                                                        } = &v163.1
                                                        {
                                                            if let &Opcode::Iconst = v166 {
                                                                let v168 =
                                                                    C::u64_from_imm64(ctx, v167);
                                                                if v168 == 0x0 {
                                                                    let v42 = C::imm64(ctx, 0x0);
                                                                    let v219 = constructor_iconst(
                                                                        ctx, v201, v42,
                                                                    );
                                                                    // Rule at src/opts/algebraic.isle line 390.
                                                                    returns.push(v219);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v197 = C::imm64(ctx, 0x1);
                                        let v198 = constructor_iconst(ctx, v40, v197);
                                        // Rule at src/opts/algebraic.isle line 350.
                                        returns.push(v198);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v42 = C::imm64(ctx, 0x0);
                                        let v43 = constructor_iconst(ctx, v40, v42);
                                        // Rule at src/opts/algebraic.isle line 329.
                                        returns.push(v43);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v197 = C::imm64(ctx, 0x1);
                                        let v198 = constructor_iconst(ctx, v40, v197);
                                        // Rule at src/opts/algebraic.isle line 332.
                                        returns.push(v198);
                                    }
                                    let v162 = C::inst_data_etor(ctx, v143.1);
                                    let mut v162 = v162;
                                    while let Some(v163) = v162.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v166,
                                            imm: v167,
                                        } = &v163.1
                                        {
                                            if let &Opcode::Iconst = v166 {
                                                let v168 = C::u64_from_imm64(ctx, v167);
                                                if v168 == 0x0 {
                                                    let v197 = C::imm64(ctx, 0x1);
                                                    let v198 = constructor_iconst(ctx, v40, v197);
                                                    // Rule at src/opts/algebraic.isle line 382.
                                                    returns.push(v198);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v42 = C::imm64(ctx, 0x0);
                                        let v43 = constructor_iconst(ctx, v40, v42);
                                        // Rule at src/opts/algebraic.isle line 341.
                                        returns.push(v43);
                                    }
                                    let v162 = C::inst_data_etor(ctx, v143.1);
                                    let mut v162 = v162;
                                    while let Some(v163) = v162.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v166,
                                            imm: v167,
                                        } = &v163.1
                                        {
                                            if let &Opcode::Iconst = v166 {
                                                let v168 = C::u64_from_imm64(ctx, v167);
                                                if v168 == 0x0 {
                                                    let v42 = C::imm64(ctx, 0x0);
                                                    let v43 = constructor_iconst(ctx, v40, v42);
                                                    // Rule at src/opts/algebraic.isle line 376.
                                                    returns.push(v43);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v37 = C::fits_in_64(ctx, v2.0);
                            if let Some(v38) = v37 {
                                let v39 = C::ty_int(ctx, v38);
                                if let Some(v40) = v39 {
                                    let v143 = C::unpack_value_array_2(ctx, v141);
                                    if v143.0 == v143.1 {
                                        let v197 = C::imm64(ctx, 0x1);
                                        let v198 = constructor_iconst(ctx, v40, v197);
                                        // Rule at src/opts/algebraic.isle line 344.
                                        returns.push(v198);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v143 = C::unpack_value_array_2(ctx, v141);
                    let v146 = C::inst_data_etor(ctx, v143.0);
                    let mut v146 = v146;
                    while let Some(v147) = v146.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v306,
                            imm: v307,
                        } = &v147.1
                        {
                            if let &Opcode::Iconst = v306 {
                                let v162 = C::inst_data_etor(ctx, v143.1);
                                let mut v162 = v162;
                                while let Some(v163) = v162.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v166,
                                        imm: v167,
                                    } = &v163.1
                                    {
                                        if let &Opcode::Iconst = v166 {
                                            if v147.0 == v163.0 {
                                                let v308 =
                                                    C::imm64_icmp(ctx, v147.0, v142, v307, v167);
                                                let v309 = constructor_iconst(ctx, v2.0, v308);
                                                let v310 = C::subsume(ctx, v309);
                                                // Rule at src/opts/cprop.isle line 79.
                                                returns.push(v310);
                                            }
                                        }
                                    }
                                }
                                let v318 = &C::intcc_reverse(ctx, v142);
                                let v319 = constructor_icmp(ctx, v2.0, v318, v143.1, v143.0);
                                // Rule at src/opts/cprop.isle line 113.
                                returns.push(v319);
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v173,
                args: ref v174,
            } => {
                match v173 {
                    &Opcode::Select => {
                        let v175 = C::unpack_value_array_3(ctx, v174);
                        let v179 = C::inst_data_etor(ctx, v175.0);
                        let mut v179 = v179;
                        while let Some(v180) = v179.next(ctx) {
                            match &v180.1 {
                                &InstructionData::FloatCompare {
                                    opcode: ref v231,
                                    args: ref v232,
                                    cond: ref v233,
                                } => {
                                    if let &Opcode::Fcmp = v231 {
                                        match v233 {
                                            &FloatCC::GreaterThan => {
                                                let v234 = C::unpack_value_array_2(ctx, v232);
                                                if v175.1 == v234.0 {
                                                    if v175.2 == v234.1 {
                                                        let v238 = constructor_fmax_pseudo(
                                                            ctx, v2.0, v234.0, v234.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 519.
                                                        returns.push(v238);
                                                    }
                                                }
                                            }
                                            &FloatCC::LessThan => {
                                                let v234 = C::unpack_value_array_2(ctx, v232);
                                                if v175.1 == v234.0 {
                                                    if v175.2 == v234.1 {
                                                        let v237 = constructor_fmin_pseudo(
                                                            ctx, v2.0, v234.0, v234.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 516.
                                                        returns.push(v237);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v221,
                                    args: ref v222,
                                    cond: ref v223,
                                } => {
                                    if let &Opcode::Icmp = v221 {
                                        match v223 {
                                            &IntCC::SignedGreaterThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 405.
                                                        returns.push(v227);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 444.
                                                        returns.push(v229);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 408.
                                                        returns.push(v227);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 447.
                                                        returns.push(v229);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 417.
                                                        returns.push(v229);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 432.
                                                        returns.push(v227);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 420.
                                                        returns.push(v229);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 435.
                                                        returns.push(v227);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 411.
                                                        returns.push(v228);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 450.
                                                        returns.push(v230);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 414.
                                                        returns.push(v228);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 453.
                                                        returns.push(v230);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 423.
                                                        returns.push(v230);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 438.
                                                        returns.push(v228);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 426.
                                                        returns.push(v230);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 441.
                                                        returns.push(v228);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v183,
                                    arg: v184,
                                } => {
                                    if let &Opcode::Uextend = v183 {
                                        let v185 = C::inst_data_etor(ctx, v184);
                                        let mut v185 = v185;
                                        while let Some(v186) = v185.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v189,
                                                args: ref v190,
                                                cond: ref v191,
                                            } = &v186.1
                                            {
                                                if let &Opcode::Icmp = v189 {
                                                    let v195 = constructor_select(
                                                        ctx, v2.0, v184, v175.1, v175.2,
                                                    );
                                                    // Rule at src/opts/algebraic.isle line 314.
                                                    returns.push(v195);
                                                    // Rule at src/opts/algebraic.isle line 317.
                                                    returns.push(v195);
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v350,
                                    imm: v351,
                                } => {
                                    if let &Opcode::Iconst = v350 {
                                        let v352 = C::u64_from_imm64(ctx, v351);
                                        if v352 == 0x0 {
                                            // Rule at src/opts/cprop.isle line 169.
                                            returns.push(v175.2);
                                        }
                                        let v353 = C::u64_is_zero(ctx, v352);
                                        if v353 == false {
                                            // Rule at src/opts/cprop.isle line 166.
                                            returns.push(v175.1);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Vselect => {
                        let v175 = C::unpack_value_array_3(ctx, v174);
                        let v179 = C::inst_data_etor(ctx, v175.0);
                        let mut v179 = v179;
                        while let Some(v180) = v179.next(ctx) {
                            match &v180.1 {
                                &InstructionData::FloatCompare {
                                    opcode: ref v231,
                                    args: ref v232,
                                    cond: ref v233,
                                } => {
                                    if let &Opcode::Fcmp = v231 {
                                        match v233 {
                                            &FloatCC::GreaterThan => {
                                                let v234 = C::unpack_value_array_2(ctx, v232);
                                                if v175.1 == v234.0 {
                                                    if v175.2 == v234.1 {
                                                        let v238 = constructor_fmax_pseudo(
                                                            ctx, v2.0, v234.0, v234.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 527.
                                                        returns.push(v238);
                                                    }
                                                }
                                            }
                                            &FloatCC::LessThan => {
                                                let v234 = C::unpack_value_array_2(ctx, v232);
                                                if v175.1 == v234.0 {
                                                    if v175.2 == v234.1 {
                                                        let v237 = constructor_fmin_pseudo(
                                                            ctx, v2.0, v234.0, v234.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 524.
                                                        returns.push(v237);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v221,
                                    args: ref v222,
                                    cond: ref v223,
                                } => {
                                    if let &Opcode::Icmp = v221 {
                                        match v223 {
                                            &IntCC::SignedGreaterThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 458.
                                                        returns.push(v227);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 496.
                                                        returns.push(v229);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 461.
                                                        returns.push(v227);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 499.
                                                        returns.push(v229);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 470.
                                                        returns.push(v229);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 484.
                                                        returns.push(v227);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v229 = constructor_smin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 473.
                                                        returns.push(v229);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v227 = constructor_smax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 487.
                                                        returns.push(v227);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 464.
                                                        returns.push(v228);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 502.
                                                        returns.push(v230);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 467.
                                                        returns.push(v228);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 505.
                                                        returns.push(v230);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 476.
                                                        returns.push(v230);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 490.
                                                        returns.push(v228);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v224 = C::unpack_value_array_2(ctx, v222);
                                                if v175.1 == v224.0 {
                                                    if v175.2 == v224.1 {
                                                        let v230 = constructor_umin(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 479.
                                                        returns.push(v230);
                                                    }
                                                }
                                                if v175.1 == v224.1 {
                                                    if v175.2 == v224.0 {
                                                        let v228 = constructor_umax(
                                                            ctx, v2.0, v224.0, v224.1,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 493.
                                                        returns.push(v228);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Fma => {
                        let v175 = C::unpack_value_array_3(ctx, v174);
                        let v179 = C::inst_data_etor(ctx, v175.0);
                        let mut v179 = v179;
                        while let Some(v180) = v179.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v183,
                                arg: v184,
                            } = &v180.1
                            {
                                if let &Opcode::Fneg = v183 {
                                    if v2.0 == v180.0 {
                                        let v239 = C::inst_data_etor(ctx, v175.1);
                                        let mut v239 = v239;
                                        while let Some(v240) = v239.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v243,
                                                arg: v244,
                                            } = &v240.1
                                            {
                                                if let &Opcode::Fneg = v243 {
                                                    if v2.0 == v240.0 {
                                                        let v245 = constructor_fma(
                                                            ctx, v2.0, v184, v244, v175.2,
                                                        );
                                                        // Rule at src/opts/algebraic.isle line 533.
                                                        returns.push(v245);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v5,
                arg: v6,
            } => {
                match v5 {
                    &Opcode::Bnot => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Binary {
                                    opcode: ref v56,
                                    args: ref v57,
                                } => {
                                    match v56 {
                                        &Opcode::Band => {
                                            let v58 = C::unpack_value_array_2(ctx, v57);
                                            let v61 = constructor_bnot(ctx, v2.0, v58.0);
                                            let v62 = constructor_bnot(ctx, v2.0, v58.1);
                                            let v64 = constructor_bor(ctx, v2.0, v61, v62);
                                            // Rule at src/opts/algebraic.isle line 144.
                                            returns.push(v64);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v8.0 {
                                                let v58 = C::unpack_value_array_2(ctx, v57);
                                                let v61 = constructor_bnot(ctx, v2.0, v58.0);
                                                let v62 = constructor_bnot(ctx, v2.0, v58.1);
                                                let v63 = constructor_band(ctx, v2.0, v61, v62);
                                                // Rule at src/opts/algebraic.isle line 141.
                                                returns.push(v63);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Bnot = v11 {
                                        if v2.0 == v8.0 {
                                            let v55 = C::subsume(ctx, v12);
                                            // Rule at src/opts/algebraic.isle line 137.
                                            returns.push(v55);
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v281,
                                    imm: v282,
                                } => {
                                    if let &Opcode::Iconst = v281 {
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            if v8.0 == v38 {
                                                let v283 = C::u64_from_imm64(ctx, v282);
                                                let v284 = C::u64_not(ctx, v283);
                                                let v285 = C::imm64_masked(ctx, v38, v284);
                                                let v286 = constructor_iconst(ctx, v38, v285);
                                                let v287 = C::subsume(ctx, v286);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v287);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v133 = C::remat(ctx, arg0);
                        // Rule at src/opts/algebraic.isle line 290.
                        returns.push(v133);
                    }
                    &Opcode::Uextend => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Uextend = v11 {
                                        let v13 = constructor_uextend(ctx, v2.0, v12);
                                        // Rule at src/opts/algebraic.isle line 10.
                                        returns.push(v13);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v281,
                                    imm: v282,
                                } => {
                                    if let &Opcode::Iconst = v281 {
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            let v297 = C::u64_uextend_imm64(ctx, v8.0, v282);
                                            let v298 = C::imm64(ctx, v297);
                                            let v299 = constructor_iconst(ctx, v38, v298);
                                            let v300 = C::subsume(ctx, v299);
                                            // Rule at src/opts/cprop.isle line 73.
                                            returns.push(v300);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v7 = C::inst_data_etor(ctx, v6);
                        let mut v7 = v7;
                        while let Some(v8) = v7.next(ctx) {
                            match &v8.1 {
                                &InstructionData::Unary {
                                    opcode: ref v11,
                                    arg: v12,
                                } => {
                                    if let &Opcode::Sextend = v11 {
                                        let v14 = constructor_sextend(ctx, v2.0, v12);
                                        // Rule at src/opts/algebraic.isle line 12.
                                        returns.push(v14);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v281,
                                    imm: v282,
                                } => {
                                    if let &Opcode::Iconst = v281 {
                                        let v37 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v38) = v37 {
                                            let v301 = C::i64_sextend_imm64(ctx, v8.0, v282);
                                            let v302 = C::i64_as_u64(ctx, v301);
                                            let v303 = C::imm64_masked(ctx, v38, v302);
                                            let v304 = constructor_iconst(ctx, v38, v303);
                                            let v305 = C::subsume(ctx, v304);
                                            // Rule at src/opts/cprop.isle line 76.
                                            returns.push(v305);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v136,
                imm: v137,
            } => {
                if let &Opcode::F32const = v136 {
                    let v133 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 294.
                    returns.push(v133);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v138,
                imm: v139,
            } => {
                if let &Opcode::F64const = v138 {
                    let v133 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 296.
                    returns.push(v133);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v134,
                imm: v135,
            } => {
                if let &Opcode::Iconst = v134 {
                    let v133 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 292.
                    returns.push(v133);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 356.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 365.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 374.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 383.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 392.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 401.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 410.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 419.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 428.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 437.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 446.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 455.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 464.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 473.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 482.
    return v6;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 491.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 500.
    return v6;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 509.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 518.
    return v6;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 527.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 536.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 545.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 554.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 563.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 572.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 581.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 590.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 599.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 608.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 617.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 626.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 635.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 644.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 653.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 662.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 671.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 680.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 689.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 698.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 707.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 716.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 725.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 734.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 743.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 752.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 761.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 770.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 779.
    return v7;
}

// Generated as internal constructor for term vselect.
pub fn constructor_vselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Vselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 788.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 797.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 806.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 815.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 824.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 833.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 842.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 851.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 860.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 869.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 878.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 887.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 896.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 905.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 914.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 923.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 932.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 941.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 950.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 959.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 968.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 977.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 986.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 995.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1004.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1013.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1022.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1031.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1040.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1049.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1058.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1067.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1076.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1085.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1094.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1103.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1112.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1121.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1130.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1139.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1148.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1157.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1166.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1175.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1184.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1193.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1202.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1211.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1220.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1229.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1238.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1247.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1256.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1265.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1274.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1283.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1292.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1301.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1310.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1319.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1328.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1337.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1346.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1355.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1364.
    return v6;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FminPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1373.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1382.
    return v6;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FmaxPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1391.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1400.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1409.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1418.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1427.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1436.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1445.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1454.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1463.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1472.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1481.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1490.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1499.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1508.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1517.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1526.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1535.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1544.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1553.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1562.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1571.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1580.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1589.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1598.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1607.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1616.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1625.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1634.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1643.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1652.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1661.
    return v4;
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtLowFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1670.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1679.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1688.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1697.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1706.
    return v5;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/afiune/github/go-sdk/hackathon-wasm/rust/wasmtime_hello/target/debug/build/cranelift-codegen-f5cf6ae366df2f83/out/clif_opt.isle line 1715.
    return v5;
}
