//
// Author:: Salim Afiune Maya (<afiune@lacework.net>)
// Copyright:: Copyright 2020, Lacework Inc.
// License:: Apache License, Version 2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package cmd

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/lacework/go-sdk/lwseverity"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"
)

var (
	vulCmdState = struct {
		// enable poll mechanism for scans status
		Poll bool

		// store the vulnerability assessment in HTML format on disk
		Html bool

		// output vulnerability assessment in CSV format
		Csv bool

		// DEPRECATED
		// when enabled we tread the provided sha256 hash as image id
		ImageID bool

		// display extended details about a vulnerability assessment
		Details bool

		// Filter the vulnerability assessment table by severity
		Severity string

		// Exit the CLI application with an error given a specified severity is met
		FailOnSeverity string

		// Exit the CLI application with an error given fixable vulnerabilities
		FailOnFixable bool

		// display only fixable vulnerabilities
		Fixable bool

		// show a list of packages by number of CVEs
		Packages bool

		// start time for listing assessments
		Start string

		// end time for listing assessments
		End string

		// natural time range for listing assessments
		Range string

		// active flag to filter container vulnerability assessments and
		// show only assessments of containers actively running
		Active bool

		// show only hosts that are online
		Online bool

		// show only hosts that are offline
		Offline bool

		// filter assessments for specific repositories
		Repositories []string

		// filter assessments for specific registries
		Registries []string

		// filter assessments by a single CVE
		Cve string

		// filter assessments by collector type(Agent/Agentless)
		CollectorType string
	}{
		// Default collector_type is agentless
		CollectorType: vulnHostCollectorTypeAgentless}

	// vulnerability represents the vulnerability command that holds both, the host
	// and container sub-commands
	vulnerabilityCmd = &cobra.Command{
		Use:     "vulnerability",
		Aliases: []string{"vuln", "vul"},
		Short:   "Container and host vulnerability assessments",
		Long:    "Container and host vulnerability assessments.",
	}

	// vulContainerCmd represents the vulnerability container command
	vulContainerCmd = &cobra.Command{
		Use:     "container",
		Aliases: []string{"ctr"},
		Short:   "Vulnerability assessment for containers",
		Long: `Request on-demand container vulnerability scans and show previous assessments
from published images.

**PREREQUISITE:** Your Lacework account should already be configured
with a Container Registry Integration of the container images you are
trying to scan or show.

To create a new integration use the following command:

    lacework container-registry create

If you prefer to configure the integration via the WebUI, log in to your account at:

    https://<ACCOUNT>.lacework.net

Then navigate to Settings > Integrations > Container Registry.`,
	}

	// vulHostCmd represents the vulnerability host command
	vulHostCmd = &cobra.Command{
		Use:   "host",
		Short: "Vulnerability assessment for hosts",
		Long: `Request on-demand host vulnerability scans and show previous assessments
from hosts with the Lacework datacollector agent installed.
`,
	}
)

const (
	vulnHostCollectorTypeAgent     string = "Agent"
	vulnHostCollectorTypeAgentless string = "Agentless"
)

func init() {
	// add the vulnerability command
	rootCmd.AddCommand(vulnerabilityCmd)

	// add sub-commands to the vulnerability command
	vulnerabilityCmd.AddCommand(vulContainerCmd)
	vulnerabilityCmd.AddCommand(vulHostCmd)
}

func setPackagesFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Packages, "packages", false,
				"show a list of packages with CVE count",
			)
		}
	}
}

func setFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Fixable, "fixable", false,
				"only show fixable vulnerabilities",
			)
		}
	}
}

func setHtmlFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Html, "html", false,
				"generate a vulnerability assessment in HTML format",
			)
		}
	}
}

func setCsvFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Csv, "csv", false,
				"output vulnerability assessment in CSV format",
			)
		}
	}
}

func setDetailsFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Details, "details", false,
				"increase details of a vulnerability assessment",
			)
		}
	}
}

func setFailOnSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.FailOnSeverity, "fail_on_severity", "",
				fmt.Sprintf("specify a severity threshold to fail if vulnerabilities are found (%s)",
					lwseverity.ValidSeverities.String()),
			)
		}
	}
}

func setFailOnFixableFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.FailOnFixable, "fail_on_fixable", false,
				"fail if the assessed container has fixable vulnerabilities",
			)
		}
	}
}

func setSeverityFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.StringVar(&vulCmdState.Severity, "severity", "",
				fmt.Sprintf("filter vulnerability assessment by severity threshold (%s)",
					lwseverity.ValidSeverities.String()),
			)
		}
	}
}

func setActiveFlag(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {
			cmd.BoolVar(&vulCmdState.Active, "active", false,
				"only show vulnerabilities of packages actively running in your environment",
			)
		}
	}
}

func setTimeRangeFlags(cmds ...*flag.FlagSet) {
	for _, cmd := range cmds {
		if cmd != nil {

			cmd.StringVar(&vulCmdState.Start,
				"start", "-24h", "start of the time range",
			)
			cmd.StringVar(&vulCmdState.End,
				"end", "now", "end of the time range",
			)
			cmd.StringVar(&vulCmdState.Range,
				"range", "", "natural time range for query",
			)
		}
	}
}

func buildVulnContainerAssessmentReportTable(summary string, details string) string {
	report := &strings.Builder{}

	report.WriteString(summary)
	if vulCmdState.Details || vulCmdState.Packages || vulFiltersEnabled() {
		report.WriteString(details)
	} else {
		if !vulCmdState.Html {
			report.WriteString(
				"Try adding '--details' to increase details shown about the vulnerability assessment.\n",
			)
		}
	}

	return report.String()
}

func byteCountBinary(b int) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])
}

func stringToInt(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		cli.Log.Debugw("unable to convert string to int",
			"string", s, "error", err.Error(), "func", "stringToInt",
		)
		return 0
	}
	return i
}

func validateSeverityFlags() error {
	if vulCmdState.Severity != "" {
		if !lwseverity.IsValid(vulCmdState.Severity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.Severity, lwseverity.ValidSeverities.String(),
			)
		}
	}

	if vulCmdState.FailOnSeverity != "" {
		if !lwseverity.IsValid(vulCmdState.FailOnSeverity) {
			return errors.Errorf("the severity %s is not valid, use one of %s",
				vulCmdState.FailOnSeverity, lwseverity.ValidSeverities.String(),
			)
		}
	}

	return nil
}

func vulFailureFlagsEnabled() bool {
	return vulCmdState.FailOnSeverity != "" || vulCmdState.FailOnFixable
}

func vulFiltersEnabled() bool {
	return vulCmdState.Severity != "" || vulCmdState.Fixable
}

func filterSeverity(severity string, threshold string) bool {
	thresholdValue, _ := lwseverity.Normalize(threshold)
	severityValue, _ := lwseverity.Normalize(severity)
	return severityValue > thresholdValue
}

// Used to store data for --package output vuln ctr/host
type packageTable struct {
	cveCount         int
	severity         string
	packageName      string
	packageNamespace string
	currentVersion   string
	fixVersion       string
	packageStatus    string
	hostCount        int
	fixes            int
}

type filteredPackageTable struct {
	packages        []packageTable
	totalPackages   int
	totalUnfiltered int
}

func (pt *packageTable) equals(p packageTable) bool {
	return pt.packageName == p.packageName &&
		pt.packageNamespace == p.packageNamespace &&
		pt.currentVersion == p.currentVersion
}
